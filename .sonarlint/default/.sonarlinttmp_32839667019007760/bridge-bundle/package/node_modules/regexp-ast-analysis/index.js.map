{"version":3,"file":"index.js","sources":[".out/util.js",".out/chars.js",".out/basic.js",".out/cache.js",".out/to-char-set.js",".out/equal.js",".out/follow.js",".out/next-char.js",".out/longest-prefix.js",".out/determinism.js",".out/reorder.js"],"sourcesContent":["import { CharSet } from \"refa\";\nimport { Chars } from \"./chars\";\nexport function assertNever(value, message) {\n    throw new Error(message || value);\n}\nexport function assertSameParent(alternatives) {\n    let parent = null;\n    for (const a of alternatives) {\n        if (parent === null) {\n            parent = a.parent;\n        }\n        else {\n            if (a.parent !== parent) {\n                throw new Error(\"Expected all alternatives to have the same parent\");\n            }\n        }\n    }\n}\nexport const isReadonlyArray = Array.isArray;\nexport function asReadonlySet(iter) {\n    if (iter instanceof Set) {\n        return iter;\n    }\n    return new Set(iter);\n}\nexport class CharUnion {\n    constructor(empty) {\n        this._exactChars = empty;\n        this._inexactChars = empty;\n    }\n    get char() {\n        return this._exactChars.union(this._inexactChars);\n    }\n    get exact() {\n        // basic idea here is that the union or an exact superset with an inexact subset will be exact\n        return this._exactChars.isSupersetOf(this._inexactChars);\n    }\n    add(char) {\n        if (char.exact) {\n            this._exactChars = this._exactChars.union(char.char);\n        }\n        else {\n            this._inexactChars = this._inexactChars.union(char.char);\n        }\n    }\n    static fromFlags(flags) {\n        return new CharUnion(Chars.empty(flags));\n    }\n    static fromMaximum(maximum) {\n        return new CharUnion(CharSet.empty(maximum));\n    }\n}\nexport function unionInexact(left, right) {\n    const char = left.char.union(right.char);\n    let exact;\n    if (left.exact) {\n        if (right.exact) {\n            exact = true;\n        }\n        else {\n            exact = left.char.isSupersetOf(right.char);\n        }\n    }\n    else {\n        if (right.exact) {\n            exact = right.char.isSupersetOf(left.char);\n        }\n        else {\n            exact = false;\n        }\n    }\n    return { char, exact };\n}\nexport function intersectInexact(left, right) {\n    const char = left.char.intersect(right.char);\n    const exact = (left.exact && right.exact) || char.isEmpty;\n    return { char, exact };\n}\nexport class SetEquivalence {\n    constructor(count) {\n        this.count = count;\n        this._indexes = [];\n        for (let i = 0; i < count; i++) {\n            this._indexes.push(i);\n        }\n    }\n    makeEqual(a, b) {\n        // This works using the following idea:\n        //  1. If the eq set of a and b is the same, then we can stop.\n        //  2. If indexes[a] < indexes[b], then we want to make\n        //     indexes[b] := indexes[a]. However, this means that we lose the\n        //     information about the indexes[b]! So we will store\n        //     oldB := indexes[b], then indexes[b] := indexes[a], and then\n        //     make oldB == a.\n        //  3. If indexes[a] > indexes[b], similar to 2.\n        let aValue = this._indexes[a];\n        let bValue = this._indexes[b];\n        while (aValue !== bValue) {\n            if (aValue < bValue) {\n                this._indexes[b] = aValue;\n                // eslint-disable-next-line no-param-reassign -- x\n                b = bValue;\n                bValue = this._indexes[b];\n            }\n            else {\n                this._indexes[a] = bValue;\n                // eslint-disable-next-line no-param-reassign -- x\n                a = aValue;\n                aValue = this._indexes[a];\n            }\n        }\n    }\n    /**\n     * This returns:\n     *\n     * 1. `eqSet.count`: How many different equivalence classes there are.\n     * 2. `eqSet.indexes`: A map (array) from each element (index) to the index\n     *    of its equivalence class.\n     *\n     * All equivalence class indexes `eqSet.indexes[i]` are guaranteed to\n     * be <= `eqSet.count`.\n     */\n    getEquivalenceSets() {\n        let counter = 0;\n        for (let i = 0; i < this.count; i++) {\n            if (i === this._indexes[i]) {\n                this._indexes[i] = counter++;\n            }\n            else {\n                this._indexes[i] = this._indexes[this._indexes[i]];\n            }\n        }\n        return {\n            count: counter,\n            indexes: this._indexes,\n        };\n    }\n}\n","/* eslint-disable @typescript-eslint/no-namespace */\nimport { CharSet, JS } from \"refa\";\n/**\n * A set of functions to get predefined character sets.\n */\nexport var Chars;\n(function (Chars) {\n    const EMPTY_UTF16_CHARSET = CharSet.empty(65535 /* UTF16 */);\n    const EMPTY_UNICODE_CHARSET = CharSet.empty(1114111 /* UNICODE */);\n    /**\n     * Returns the empty character set for the given flags.\n     */\n    function empty(flags) {\n        if (flags.unicode) {\n            return EMPTY_UNICODE_CHARSET;\n        }\n        else {\n            return EMPTY_UTF16_CHARSET;\n        }\n    }\n    Chars.empty = empty;\n    const ALL_UTF16_CHARSET = CharSet.all(65535 /* UTF16 */);\n    const ALL_UNICODE_CHARSET = CharSet.all(1114111 /* UNICODE */);\n    /**\n     * Returns the full character set for the given flags.\n     */\n    function all(flags) {\n        if (flags.unicode) {\n            return ALL_UNICODE_CHARSET;\n        }\n        else {\n            return ALL_UTF16_CHARSET;\n        }\n    }\n    Chars.all = all;\n    const LINE_TERMINATOR_UTF16_CHARSET = JS.createCharSet([{ kind: \"any\" }], { unicode: false }).negate();\n    const LINE_TERMINATOR_UNICODE_CHARSET = JS.createCharSet([{ kind: \"any\" }], { unicode: true }).negate();\n    /**\n     * Returns the character set that contains only line terminators.\n     *\n     * This character set accepts all characters that the JS RegExp `.` rejects. The returned character set accepts\n     * all character that the regex `/^.$/` rejects.\n     */\n    function lineTerminator(flags) {\n        if (flags.unicode) {\n            return LINE_TERMINATOR_UNICODE_CHARSET;\n        }\n        else {\n            return LINE_TERMINATOR_UTF16_CHARSET;\n        }\n    }\n    Chars.lineTerminator = lineTerminator;\n    const WORD_UTF16_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], { unicode: false });\n    const WORD_UNICODE_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], {\n        unicode: true,\n        ignoreCase: false,\n    });\n    const WORD_UNICODE_IGNORE_CASE_CHARSET = JS.createCharSet([{ kind: \"word\", negate: false }], {\n        unicode: true,\n        ignoreCase: true,\n    });\n    /**\n     * Returns a character set that is equivalent to `\\w` with the given flags.\n     *\n     * Note: `\\w` is somewhat special because it has 3 values. All predefined character sets only have two values - one\n     * for Unicode mode and one for non-Unicode mode. This is because Unicode-mode changes the semantics of ignore case\n     * as well. This causes some of the ASCII letters to be ignore-case-equal to higher Unicode characters\n     * (e.g. K (Latin Capital Letter K, U+004b) == k (Latin Small Letter K, U+006b) == â„ª (Kelvin Sign, U+212A)). As a\n     * result `\\w` has 3 values: one for non-Unicode mode, one for case-sensitive Unicode-mode, and one for\n     * case-insensitive Unicode-mode.\n     */\n    function word(flags) {\n        if (flags.unicode) {\n            if (flags.ignoreCase) {\n                return WORD_UNICODE_IGNORE_CASE_CHARSET;\n            }\n            else {\n                return WORD_UNICODE_CHARSET;\n            }\n        }\n        else {\n            return WORD_UTF16_CHARSET;\n        }\n    }\n    Chars.word = word;\n    const DIGIT_UTF16_CHARSET = JS.createCharSet([{ kind: \"digit\", negate: false }], { unicode: false });\n    const DIGIT_UNICODE_CHARSET = JS.createCharSet([{ kind: \"digit\", negate: false }], { unicode: true });\n    /**\n     * Returns a character set that is equivalent to `\\d` with the given flags.\n     */\n    function digit(flags) {\n        if (flags.unicode) {\n            return DIGIT_UNICODE_CHARSET;\n        }\n        else {\n            return DIGIT_UTF16_CHARSET;\n        }\n    }\n    Chars.digit = digit;\n    const SPACE_UTF16_CHARSET = JS.createCharSet([{ kind: \"space\", negate: false }], { unicode: false });\n    const SPACE_UNICODE_CHARSET = JS.createCharSet([{ kind: \"space\", negate: false }], { unicode: true });\n    /**\n     * Returns a character set that is equivalent to `\\s` with the given flags.\n     */\n    function space(flags) {\n        if (flags.unicode) {\n            return SPACE_UNICODE_CHARSET;\n        }\n        else {\n            return SPACE_UTF16_CHARSET;\n        }\n    }\n    Chars.space = space;\n})(Chars || (Chars = {}));\n","import { visitRegExpAST } from \"@eslint-community/regexpp\";\nimport { assertNever, isReadonlyArray } from \"./util\";\nfunction isInvokeEvery(element, fn) {\n    if (isReadonlyArray(element)) {\n        return element.every(fn);\n    }\n    else {\n        return fn(element);\n    }\n}\nfunction isInvokeSome(element, fn) {\n    if (isReadonlyArray(element)) {\n        return element.some(fn);\n    }\n    else {\n        return fn(element);\n    }\n}\n/**\n * Returns whether all (but at least one of the) paths of the given element do not consume characters.\n *\n * If this function returns `true`, then {@link isPotentiallyZeroLength} is guaranteed to return `true`.\n *\n * ## Backreferences\n *\n * This function uses the same condition for backreferences as {@link isEmpty}.\n *\n * ## Relations\n *\n * - `isZeroLength(e) -> isPotentiallyZeroLength(e)`\n * - `isZeroLength(e) -> getLengthRange(e).max == 0`\n *\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isZeroLength(element) {\n    return isInvokeEvery(element, isZeroLengthImpl);\n}\nfunction isZeroLengthImpl(element) {\n    switch (element.type) {\n        case \"Alternative\":\n            return element.elements.every(isZeroLengthImpl);\n        case \"Assertion\":\n            return true;\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n            return false;\n        case \"Quantifier\":\n            return element.max === 0 || isZeroLengthImpl(element.element);\n        case \"Backreference\":\n            return isEmptyBackreference(element);\n        case \"CapturingGroup\":\n        case \"Group\":\n            return element.alternatives.length > 0 && element.alternatives.every(isZeroLengthImpl);\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether at least one path of the given element does not consume characters.\n *\n * ## Backreferences\n *\n * This function uses the same condition for backreferences as {@link isPotentiallyEmpty}.\n *\n * ## Relations\n *\n * - `isPotentiallyZeroLength(e) -> getLengthRange(e).min == 0`\n *\n * @see {@link isZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isPotentiallyZeroLength(element) {\n    return isInvokeSome(element, e => isPotentiallyZeroLengthImpl(e, e));\n}\nfunction isPotentiallyZeroLengthImpl(e, root) {\n    return impl(e);\n    function impl(element) {\n        switch (element.type) {\n            case \"Alternative\":\n                return element.elements.every(impl);\n            case \"Assertion\":\n                return true;\n            case \"Backreference\":\n                return backreferenceIsPotentiallyEmpty(element, root);\n            case \"Character\":\n            case \"CharacterClass\":\n            case \"CharacterSet\":\n                return false;\n            case \"CapturingGroup\":\n            case \"Group\":\n                return element.alternatives.some(impl);\n            case \"Quantifier\":\n                return element.min === 0 || impl(element.element);\n            default:\n                throw assertNever(element);\n        }\n    }\n}\n/**\n * Returns whether all (but at least one of the) paths of the given element do neither consume characters nor assert\n * characters.\n *\n * If this function returns `true`, then {@link isZeroLength} and {@link isPotentiallyEmpty} are guaranteed to return\n * `true`.\n *\n * ## Backreferences\n *\n * A backreferences will only be considered potentially empty, iff it is empty by the definition of\n * {@link isEmptyBackreference}.\n *\n * ## Relations\n *\n * - `isEmpty(e) -> isZeroLength(e)`\n * - `isEmpty(e) -> isPotentiallyEmpty(e)`\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isPotentiallyEmpty}\n * @see {@link getLengthRange}\n */\nexport function isEmpty(element) {\n    return isInvokeEvery(element, isEmptyImpl);\n}\nfunction isEmptyImpl(element) {\n    switch (element.type) {\n        case \"Alternative\":\n            return element.elements.every(isEmptyImpl);\n        case \"Assertion\":\n            return false;\n        case \"Backreference\":\n            return isEmptyBackreference(element);\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n            return false;\n        case \"CapturingGroup\":\n        case \"Group\":\n            return element.alternatives.length > 0 && element.alternatives.every(isEmptyImpl);\n        case \"Quantifier\":\n            return element.max === 0 || isEmptyImpl(element.element);\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether at least one path of the given element does neither consume characters nor assert characters.\n *\n * ## Backreferences\n *\n * A backreferences will only be considered potentially empty, iff at least one of the following conditions is true:\n *\n * - The backreference is trivially always empty. (see {@link isEmptyBackreference})\n * - The referenced capturing group is a descendant of the given element and at least one of the following conditions is\n *   true:\n *   * The referenced capturing group is potentially zero-length.\n *   * The backreferences is not always after its referenced capturing group.\n *     (see {@link isStrictBackreference})\n *\n * ## Relations\n *\n * - `isPotentiallyEmpty(e) -> isPotentiallyZeroLength(e)`\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link getLengthRange}\n */\nexport function isPotentiallyEmpty(element) {\n    return isInvokeSome(element, isPotentiallyEmptyImpl);\n}\nfunction isPotentiallyEmptyImpl(root) {\n    return impl(root);\n    function impl(element) {\n        switch (element.type) {\n            case \"Alternative\":\n                return element.elements.every(impl);\n            case \"Assertion\":\n                return false;\n            case \"Backreference\":\n                return backreferenceIsPotentiallyEmpty(element, root);\n            case \"Character\":\n            case \"CharacterClass\":\n            case \"CharacterSet\":\n                return false;\n            case \"CapturingGroup\":\n            case \"Group\":\n                return element.alternatives.some(impl);\n            case \"Quantifier\":\n                return element.min === 0 || impl(element.element);\n            default:\n                throw assertNever(element);\n        }\n    }\n}\nfunction backreferenceIsPotentiallyEmpty(back, root) {\n    if (isEmptyBackreference(back)) {\n        return true;\n    }\n    else if (hasSomeAncestor(back.resolved, a => a === root)) {\n        return !isStrictBackreference(back) || isPotentiallyZeroLengthImpl(back.resolved, root);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Returns whether any of the ancestors of the given node fulfills the given condition.\n *\n * If the given condition is an AST node instead of a function, `hasSomeAncestor` will behave as if the condition\n * function was `d => d === conditionNode`.\n *\n * The ancestors will be iterated in the order from closest to farthest.\n * The condition function will not be called on the given node.\n */\nexport function hasSomeAncestor(node, condition) {\n    if (typeof condition === \"function\") {\n        return hasSomeAncestorFnImpl(node, condition);\n    }\n    else {\n        return hasSomeAncestorNodeImpl(node, condition);\n    }\n}\nfunction hasSomeAncestorNodeImpl(node, condition) {\n    let parent = node.parent;\n    while (parent) {\n        if (parent === condition) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction hasSomeAncestorFnImpl(node, condition) {\n    let parent = node.parent;\n    while (parent) {\n        if (condition(parent)) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns whether any of the descendants of the given node fulfill the given condition.\n *\n * The descendants will be iterated in a DFS top-to-bottom manner from left to right with the first node being the\n * given node.\n *\n * If the given condition is an AST node instead of a function, `hasSomeDescendant` will behave as if the condition\n * function was `d => d === conditionNode`.\n *\n * This function is short-circuited, so as soon as any `condition` returns `true`, `true` will be returned.\n *\n * @param node\n * @param condition\n * @param descentConditionFn An optional function to decide whether the descendant of the given node will be checked as\n * well.\n *\n * This function will be called with some node only after `condition` has returned `false` for this node.\n */\nexport function hasSomeDescendant(node, condition, descentConditionFn) {\n    if (typeof condition === \"function\") {\n        return hasSomeDescendantImpl(node, condition, descentConditionFn);\n    }\n    else {\n        if (descentConditionFn) {\n            return hasSomeDescendantImpl(node, d => d === condition, descentConditionFn);\n        }\n        else {\n            // instead of checking the O(n) descendant nodes of `node`, we can instead check the O(log n) ancestor\n            // nodes of `condition`\n            return node === condition || hasSomeAncestor(condition, node);\n        }\n    }\n}\nfunction hasSomeDescendantImpl(node, conditionFn, descentConditionFn) {\n    if (conditionFn(node)) {\n        return true;\n    }\n    if (descentConditionFn && !descentConditionFn(node)) {\n        return false;\n    }\n    switch (node.type) {\n        case \"Alternative\":\n            return node.elements.some(e => hasSomeDescendantImpl(e, conditionFn, descentConditionFn));\n        case \"Assertion\":\n            if (node.kind === \"lookahead\" || node.kind === \"lookbehind\") {\n                return node.alternatives.some(a => hasSomeDescendantImpl(a, conditionFn, descentConditionFn));\n            }\n            return false;\n        case \"CapturingGroup\":\n        case \"Group\":\n        case \"Pattern\":\n            return node.alternatives.some(a => hasSomeDescendantImpl(a, conditionFn, descentConditionFn));\n        case \"CharacterClass\":\n            return node.elements.some(e => hasSomeDescendantImpl(e, conditionFn, descentConditionFn));\n        case \"CharacterClassRange\":\n            return (hasSomeDescendantImpl(node.min, conditionFn, descentConditionFn) ||\n                hasSomeDescendantImpl(node.max, conditionFn, descentConditionFn));\n        case \"Quantifier\":\n            return hasSomeDescendantImpl(node.element, conditionFn, descentConditionFn);\n        case \"RegExpLiteral\":\n            return (hasSomeDescendantImpl(node.pattern, conditionFn, descentConditionFn) ||\n                hasSomeDescendantImpl(node.flags, conditionFn, descentConditionFn));\n    }\n    return false;\n}\n/**\n * Returns the one-based number of the given capturing group.\n *\n * This is the number needed to refer to the capturing group via backreferences.\n */\nexport function getCapturingGroupNumber(group) {\n    let found = 0;\n    try {\n        visitRegExpAST(getPattern(group), {\n            onCapturingGroupEnter(node) {\n                found++;\n                if (node === group) {\n                    // throw an error to end early\n                    throw new Error();\n                }\n            },\n        });\n        throw new Error(\"Unable to find the given capturing group in its parent pattern.\");\n    }\n    catch (error) {\n        return found;\n    }\n}\n/**\n * Returns the pattern node of the JS RegExp of a given node.\n *\n * This operation is guaranteed to always success for all node types except for flags nodes. Flags nodes have an\n * optional `parent` which, if not set, means that this function can't access the pattern node. If the function can't\n * access the pattern node from a flags node, an error will be thrown.\n */\nexport function getPattern(node) {\n    switch (node.type) {\n        case \"RegExpLiteral\":\n            return node.pattern;\n        case \"Pattern\":\n            return node;\n        case \"Flags\":\n            if (node.parent) {\n                return node.parent.pattern;\n            }\n            else {\n                throw new Error(\"Unable to find the pattern of flags without a RegExp literal.\");\n            }\n        default: {\n            let p = node.parent;\n            while (p.type !== \"Pattern\") {\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n}\n/**\n * Returns the direction which which the given node will be matched relative to the closest parent alternative.\n *\n * If the given node is a lookaround, then the result of `getMatchingDirection(lookaround)` will be the same as\n * `getMatchingDirection(lookaround.parent)`.\n */\nexport function getMatchingDirection(node) {\n    let closestLookaround;\n    hasSomeAncestor(node, a => {\n        if (a.type === \"Assertion\") {\n            closestLookaround = a;\n            return true;\n        }\n        return false;\n    });\n    if (closestLookaround === undefined) {\n        // left-to-right matching is assumed\n        return \"ltr\";\n    }\n    else if (closestLookaround.kind === \"lookahead\") {\n        return \"ltr\";\n    }\n    else {\n        return \"rtl\";\n    }\n}\n/**\n * Returns the opposite matching direction of the given matching direction.\n *\n * If `ltr` is given, `rtl` will be returned and vise versa.\n */\nexport function invertMatchingDirection(direction) {\n    return direction === \"ltr\" ? \"rtl\" : \"ltr\";\n}\n/**\n * Converts a given assertion kind into a matching direction.\n *\n * For lookaheads and lookbehinds, the returned matching direction will be the matching direction of their children.\n * I.e. the result of `lookahead` is `ltr` and the result of `lookbehind` is `rtl`.\n *\n * For edge assertions (`^` and `$`), the returned value is the direction of the character the edge assertion asserts.\n * I.e. the result of `^` is `rtl` (because it asserts the previous character) and the result of `$` is `ltr` (because\n * it asserts the next character).\n */\nexport function getMatchingDirectionFromAssertionKind(kind) {\n    return kind === \"end\" || kind === \"lookahead\" ? \"ltr\" : \"rtl\";\n}\n/**\n * Returns whether the given backreference will always be replaced with the empty string.\n *\n * There are two reasons why a backreference might always be replaced with the empty string:\n *\n * 1. The referenced capturing group does not consume characters.\n *\n *    This is the trivial case. If the referenced capturing group never consumes any characters, then a backreference to\n *    that group must be replaced with the empty string.\n *\n *    E.g. `/(\\b)a\\1/`\n *\n * 2. The backreference is not after the referenced capturing group.\n *\n *    A backreference can only be replaced with a non-empty string if the referenced capturing group has captured text\n *    before the backreference is matched. There are multiple reasons why the capturing group might be unable to capture\n *    text before a backreference to it is reached.\n *\n *    - The capturing group might be in a different alternative. E.g. `/(a)b|\\1/`.\n *    - The backreference might be *inside* the capturing group. E.g. `/(a\\1)/`.\n *    - The backreference might be before the capturing group. E.g. `/\\1(a)/`, `/(?:\\1(a))+/`, `/(?<=(a)\\1)b/`\n */\nexport function isEmptyBackreference(backreference) {\n    const group = backreference.resolved;\n    const closestAncestor = getClosestAncestor(backreference, group);\n    if (closestAncestor === group) {\n        // if the backreference is element of the referenced group\n        return true;\n    }\n    if (closestAncestor.type !== \"Alternative\") {\n        // if the closest common ancestor isn't an alternative => they're disjunctive.\n        return true;\n    }\n    const backRefAncestors = new Set();\n    for (let a = backreference; a; a = a.parent) {\n        backRefAncestors.add(a);\n    }\n    // Now for the hard part:\n    // If there exists a path through the regular expression which connect the group and the backreference, then\n    // the backreference can capture the group iff we only move up, down, or right relative to the group.\n    function findBackreference(node) {\n        const parent = node.parent;\n        switch (parent.type) {\n            case \"Alternative\": {\n                // if any elements right to the given node contain or are the backreference, we found it.\n                const index = parent.elements.indexOf(node);\n                // we have to take the current matching direction into account\n                let next;\n                if (getMatchingDirection(node) === \"ltr\") {\n                    // the next elements to match will be right to the given node\n                    next = parent.elements.slice(index + 1);\n                }\n                else {\n                    // the next elements to match will be left to the given node\n                    next = parent.elements.slice(0, index);\n                }\n                if (next.some(e => backRefAncestors.has(e))) {\n                    return true;\n                }\n                // no luck. let's go up!\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    // can't go up.\n                    return false;\n                }\n                else if (parentParent.type === \"Assertion\" && parentParent.negate) {\n                    // The captured text of a capturing group will be reset after leaving a negated lookaround\n                    return false;\n                }\n                else {\n                    return findBackreference(parentParent);\n                }\n            }\n            case \"Quantifier\":\n                return findBackreference(parent);\n        }\n    }\n    return !findBackreference(group) || isZeroLength(group);\n}\n/**\n * Returns whether the given backreference is a strict backreference.\n *\n * Strict backreferences are backreferences that are always matched __after__ the referenced group was matched. If there\n * exists any path that goes through a backreference but not through the referenced capturing group, that backreference\n * is not strict.\n *\n * ## Examples\n *\n * In the follow examples, `\\1` is a strict backreference:\n *\n * - `/(a)\\1/`\n * - `/(a)(?:b|\\1)/`\n * - `/(a)\\1?/`\n * - `/(?<=\\1(a))b/`\n *\n * In the follow examples, `\\1` is not a strict backreference:\n *\n * - `/(a)|\\1/`\n * - `/(?:(a)|b)\\1/`\n * - `/(a)?\\1/`\n * - `/(?<=(a)\\1)b/`\n * - `/(?!(a)).\\1/`\n */\nexport function isStrictBackreference(backreference) {\n    const group = backreference.resolved;\n    const closestAncestor = getClosestAncestor(backreference, group);\n    if (closestAncestor === group) {\n        // if the backreference is element of the referenced group\n        return false;\n    }\n    if (closestAncestor.type !== \"Alternative\") {\n        // if the closest common ancestor isn't an alternative => they're disjunctive.\n        return false;\n    }\n    const backRefAncestors = new Set();\n    for (let a = backreference; a; a = a.parent) {\n        backRefAncestors.add(a);\n    }\n    function findBackreference(node) {\n        const parent = node.parent;\n        switch (parent.type) {\n            case \"Alternative\": {\n                // if any elements right to the given node contain or are the backreference, we found it.\n                const index = parent.elements.indexOf(node);\n                // we have to take the current matching direction into account\n                let next;\n                if (getMatchingDirection(node) === \"ltr\") {\n                    // the next elements to match will be right to the given node\n                    next = parent.elements.slice(index + 1);\n                }\n                else {\n                    // the next elements to match will be left to the given node\n                    next = parent.elements.slice(0, index);\n                }\n                if (next.some(e => backRefAncestors.has(e))) {\n                    return true;\n                }\n                // no luck. let's go up!\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    // can't go up.\n                    return false;\n                }\n                else if (parentParent.type === \"Assertion\" && parentParent.negate) {\n                    // The captured text of a capturing group will be reset after leaving a negated lookaround\n                    return false;\n                }\n                else {\n                    if (parentParent.alternatives.length > 1) {\n                        // e.g.: (?:a|(a))+b\\1\n                        return false;\n                    }\n                    return findBackreference(parentParent);\n                }\n            }\n            case \"Quantifier\":\n                if (parent.min === 0) {\n                    // e.g.: (a+)?b\\1\n                    return false;\n                }\n                return findBackreference(parent);\n        }\n    }\n    return findBackreference(group);\n}\n/**\n * Returns whether the given node contains or is a capturing group.\n *\n * This function is guaranteed to behave in the same way as:\n *\n * ```js\n * hasSomeDescendant(node, d => d.type === \"CapturingGroup\")\n * ```\n */\nexport function containsCapturingGroup(node) {\n    return hasSomeDescendant(node, isCapturingGroup);\n}\nfunction isCapturingGroup(node) {\n    return node.type === \"CapturingGroup\";\n}\nconst ZERO_LENGTH_RANGE = { min: 0, max: 0 };\nconst ONE_LENGTH_RANGE = { min: 1, max: 1 };\n/**\n * Returns how many characters the given element can consume at most and has to consume at least.\n *\n * Note that character classes are not parsed by this function and are assumed to be non-empty.\n *\n * ## Backreferences\n *\n * While {@link isPotentiallyZeroLength} generally assumes the worst-case for backreferences that references capturing group\n * outside the given element, this function does not/cannot. The length range of a backreference only depends on the\n * referenced capturing group and the relative positions of the backreference and the capturing group within the\n * pattern. It does not depend on the given element.\n *\n * This is an important distinction because it means that `isPotentiallyZeroLength(e) -> getLengthRange(e).min == 0` is\n * guaranteed but `getLengthRange(e).min == 0 -> isPotentiallyZeroLength(e)` is only guaranteed if `e` does not contain\n * backreferences.\n *\n * @throws {RangeError} if an empty array of alternatives is given.\n *\n * @see {@link isZeroLength}\n * @see {@link isPotentiallyZeroLength}\n * @see {@link isEmpty}\n * @see {@link isPotentiallyEmpty}\n */\nexport function getLengthRange(element) {\n    if (isReadonlyArray(element)) {\n        return getLengthRangeAlternativesImpl(element);\n    }\n    else {\n        return getLengthRangeElementImpl(element);\n    }\n}\nfunction getLengthRangeAlternativesImpl(alternatives) {\n    let min = Infinity;\n    let max = 0;\n    for (const a of alternatives) {\n        const eRange = getLengthRangeElementImpl(a);\n        min = Math.min(min, eRange.min);\n        max = Math.max(max, eRange.max);\n    }\n    if (min > max) {\n        throw new RangeError(\"Expected the alternatives array to have at least one alternative.\");\n    }\n    else {\n        return { min, max };\n    }\n}\nfunction getLengthRangeElementImpl(element) {\n    switch (element.type) {\n        case \"Assertion\":\n            return ZERO_LENGTH_RANGE;\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n            return ONE_LENGTH_RANGE;\n        case \"Quantifier\": {\n            if (element.max === 0) {\n                return ZERO_LENGTH_RANGE;\n            }\n            const elementRange = getLengthRangeElementImpl(element.element);\n            if (elementRange.max === 0) {\n                return ZERO_LENGTH_RANGE;\n            }\n            else {\n                return { min: elementRange.min * element.min, max: elementRange.max * element.max };\n            }\n        }\n        case \"Alternative\": {\n            let min = 0;\n            let max = 0;\n            for (const e of element.elements) {\n                const eRange = getLengthRangeElementImpl(e);\n                min += eRange.min;\n                max += eRange.max;\n            }\n            return { min, max };\n        }\n        case \"CapturingGroup\":\n        case \"Group\":\n            return getLengthRangeAlternativesImpl(element.alternatives);\n        case \"Backreference\": {\n            if (isEmptyBackreference(element)) {\n                return ZERO_LENGTH_RANGE;\n            }\n            else {\n                const resolvedRange = getLengthRangeElementImpl(element.resolved);\n                if (resolvedRange.min > 0 && !isStrictBackreference(element)) {\n                    return { min: 0, max: resolvedRange.max };\n                }\n                else {\n                    return resolvedRange;\n                }\n            }\n        }\n        default:\n            throw assertNever(element);\n    }\n}\n/**\n * Returns whether `getLengthRange(e).min == 0`.\n *\n * This function is slightly different from {@link isPotentiallyZeroLength} in how it handles backreferences. See the\n * notes on backreferences in the documentation of {@link isPotentiallyZeroLength} and {@link getLengthRange} for more\n * information.\n *\n * ## Relations\n *\n * - `isLengthRangeMinZero(e) <-> getLengthRange(e).min == 0`\n *\n * @throws {RangeError} if an empty array of alternatives is given.\n *\n * @see {@link getLengthRange}\n */\nexport function isLengthRangeMinZero(element) {\n    if (isReadonlyArray(element)) {\n        return isLengthRangeMinZeroAlternativesImpl(element);\n    }\n    else {\n        return isLengthRangeMinZeroElementImpl(element);\n    }\n}\nfunction isLengthRangeMinZeroAlternativesImpl(alternatives) {\n    if (alternatives.length === 0) {\n        throw new RangeError(\"Expected the alternatives array to have at least one alternative.\");\n    }\n    return alternatives.some(isLengthRangeMinZeroElementImpl);\n}\nfunction isLengthRangeMinZeroElementImpl(element) {\n    switch (element.type) {\n        case \"Assertion\":\n            return true;\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n            return false;\n        case \"Quantifier\":\n            return element.min === 0 || isLengthRangeMinZeroElementImpl(element.element);\n        case \"Alternative\":\n            return element.elements.every(isLengthRangeMinZeroElementImpl);\n        case \"CapturingGroup\":\n        case \"Group\":\n            return isLengthRangeMinZeroAlternativesImpl(element.alternatives);\n        case \"Backreference\": {\n            return (isEmptyBackreference(element) ||\n                !isStrictBackreference(element) ||\n                isLengthRangeMinZeroElementImpl(element.resolved));\n        }\n        default:\n            throw assertNever(element);\n    }\n}\nexport function getClosestAncestor(...args) {\n    if (args.length === 0)\n        return undefined;\n    return args.reduce(getClosestAncestorImpl);\n}\nfunction getClosestAncestorImpl(a, b) {\n    if (a === b) {\n        // trivial\n        return a;\n    }\n    else if (a.parent && a.parent === b.parent) {\n        // this case is quite common and doesn't require any memory allocation\n        return a.parent;\n    }\n    else {\n        const aPath = getPathToRoot(a);\n        const bPath = getPathToRoot(b);\n        while (true) {\n            if (aPath.length === 0) {\n                return a;\n            }\n            else if (bPath.length === 0) {\n                return b;\n            }\n            else if (aPath[aPath.length - 1] === bPath[bPath.length - 1]) {\n                aPath.pop();\n                bPath.pop();\n            }\n            else {\n                break;\n            }\n        }\n        const p = aPath[aPath.length - 1].parent;\n        if (p) {\n            return p;\n        }\n        throw new Error(\"The two nodes are not part of the same tree.\");\n    }\n}\nfunction getPathToRoot(a) {\n    const path = [];\n    for (let an = a; an; an = an.parent) {\n        path.push(an);\n    }\n    return path;\n}\n/**\n * Returns how many times the regex engine can match the given element at most.\n *\n * This method will treat elements inside lookarounds differently. Elements inside lookarounds will ignore everything\n * outside the lookaround.\n *\n * ## Examples\n *\n * - `/a?/`: This will return 1 for `a`.\n * - `/a+/`: This will return infinity for `a` and 1 for the quantifier `a+`.\n * - `/((a{0,8}){0,8}){0,8}/`: This will return 512 for `a`.\n * - `/(ba{0})+/`: This will return 0 for `a` and infinity for the quantifier `a{0}`.\n * - `/(\\w(?!a{3}b))+/`: This will return 3 for `a` because `a` is inside a lookaround and therefore unaffected by the\n *   `(\\w(?!a{3}b)))+` quantifier.\n */\nexport function getEffectiveMaximumRepetition(element) {\n    let max = 1;\n    for (let n = element.parent; n; n = n.parent) {\n        if (n.type === \"Quantifier\") {\n            max *= n.max;\n            if (max === 0) {\n                return 0;\n            }\n        }\n        else if (n.type === \"Assertion\") {\n            break;\n        }\n    }\n    return max;\n}\n","/**\n * This will create a new cache instance for the given flags.\n *\n * This operation will always create a new cache. If you want to transparently reuse cache instances, use\n * {@link toCache} instead.\n *\n * See {@link Cache} from more information about using caches.\n *\n * @see {@link Cache}\n * @see {@link toCache}\n */\nexport function createCache(flags) {\n    return new CacheInstance(flags);\n}\n/**\n * Returns a cache instance for the given flags.\n *\n * If the given flags are a cache instance, the cache instance will be returned. Otherwise a new cache instance will\n * be created using {@link createCache}.\n *\n * See {@link Cache} from more information about using caches.\n *\n * @see {@link Cache}\n * @see {@link createCache}\n */\nexport function toCache(flags) {\n    return CacheInstance.from(flags);\n}\n/** @internal */\nexport class CacheInstance {\n    constructor(flags) {\n        this.toCharSet = new WeakMap();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.getFirstConsumedCharLTR = new WeakMap();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.getFirstConsumedCharRTL = new WeakMap();\n        this.getLongestPrefix = new Map();\n        this.dotAll = !!flags.dotAll;\n        this.global = !!flags.global;\n        this.hasIndices = !!flags.hasIndices;\n        this.ignoreCase = !!flags.ignoreCase;\n        this.multiline = !!flags.multiline;\n        this.sticky = !!flags.sticky;\n        this.unicode = !!flags.unicode;\n    }\n    static from(flags) {\n        if (flags instanceof CacheInstance) {\n            return flags;\n        }\n        else {\n            return new CacheInstance(flags);\n        }\n    }\n}\n","import { JS } from \"refa\";\nimport { CacheInstance } from \"./cache\";\nimport { Chars } from \"./chars\";\nimport { assertNever, isReadonlyArray } from \"./util\";\n/**\n * Converts the given element or array of elements into a refa CharSet.\n *\n * If an array is given, all the character sets of all elements will be unioned. This means that for any two element `a`\n * and `b`, the results of `toCharSet([a, b])` and `toCharSet(a).union(toCharSet(b))` will be the same.\n */\nexport function toCharSet(elements, flags) {\n    if (!isReadonlyArray(elements)) {\n        return toCharSetSimpleCached(elements, flags);\n    }\n    else if (elements.length === 1) {\n        return toCharSetSimpleCached(elements[0], flags);\n    }\n    const { positive, negated } = categorizeElements(elements);\n    if (negated.length) {\n        if (positive.length) {\n            return JS.createCharSet(makeRefaCompatible(positive), flags).union(...negated.map(c => JS.createCharSet(makeRefaCompatible(c.elements), flags).negate()));\n        }\n        else {\n            if (negated.length === 1) {\n                return JS.createCharSet(makeRefaCompatible(negated[0].elements), flags).negate();\n            }\n            else {\n                return Chars.empty(flags).union(...negated.map(c => JS.createCharSet(makeRefaCompatible(c.elements), flags).negate()));\n            }\n        }\n    }\n    else if (positive.length) {\n        return JS.createCharSet(makeRefaCompatible(positive), flags);\n    }\n    else {\n        return Chars.empty(flags);\n    }\n}\nfunction toCharSetSimpleCached(element, flags) {\n    if (flags instanceof CacheInstance) {\n        let cached = flags.toCharSet.get(element);\n        if (cached === undefined) {\n            cached = toCharSetSimple(element, flags);\n            flags.toCharSet.set(element, cached);\n        }\n        return cached;\n    }\n    else {\n        return toCharSetSimple(element, flags);\n    }\n}\nfunction toCharSetSimple(element, flags) {\n    if (element.type === \"CharacterClass\") {\n        const cs = JS.createCharSet(makeRefaCompatible(element.elements), flags);\n        return element.negate ? cs.negate() : cs;\n    }\n    return JS.createCharSet([toRefaCharElement(element)], flags);\n}\nfunction categorizeElements(elements) {\n    const positive = [];\n    const negated = [];\n    for (const e of elements) {\n        if (e.type === \"CharacterClass\") {\n            if (e.negate) {\n                negated.push(e);\n            }\n            else {\n                positive.push(...e.elements);\n            }\n        }\n        else {\n            positive.push(e);\n        }\n    }\n    return { positive, negated };\n}\nfunction makeRefaCompatible(elements) {\n    return elements.map(toRefaCharElement);\n}\nfunction toRefaCharElement(e) {\n    switch (e.type) {\n        case \"Character\":\n            return e.value;\n        case \"CharacterClassRange\":\n            return { min: e.min.value, max: e.max.value };\n        case \"CharacterSet\":\n            return e;\n        default:\n            throw assertNever(e);\n    }\n}\n/**\n * Returns whether the given character class/set matches all characters.\n *\n * This is guaranteed to be equivalent to `toCharSet(char).isAll` but is implemented more efficiently.\n */\nexport function matchesAllCharacters(char, flags) {\n    if (char.type === \"Character\") {\n        return false;\n    }\n    else if (char.type === \"CharacterClassRange\") {\n        return char.min.value === 0 && char.max.value === (flags.unicode ? 1114111 /* UNICODE */ : 65535 /* UTF16 */);\n    }\n    else if (char.type === \"CharacterSet\") {\n        if (char.kind === \"property\") {\n            return toCharSet(char, flags).isAll;\n        }\n        else if (char.kind === \"any\") {\n            return !!flags.dotAll;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        if (char.negate && char.elements.length === 0) {\n            return true;\n        }\n        else {\n            if (char.negate) {\n                return toCharSet(char.elements, flags).isEmpty;\n            }\n            else {\n                return toCharSet(char.elements, flags).isAll;\n            }\n        }\n    }\n}\n/**\n * Returns whether the given character class/set matches no characters.\n *\n * This is guaranteed to be equivalent to `toCharSet(char).isEmpty` but is implemented more efficiently.\n */\nexport function matchesNoCharacters(char, flags) {\n    if (char.type === \"Character\" || char.type === \"CharacterClassRange\") {\n        // both are guaranteed to match at least one character\n        return false;\n    }\n    else if (char.type === \"CharacterSet\") {\n        if (char.kind === \"property\") {\n            return toCharSet(char, flags).isEmpty;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        if (!char.negate && char.elements.length === 0) {\n            return true;\n        }\n        else {\n            if (char.negate) {\n                return toCharSet(char.elements, flags).isAll;\n            }\n            else {\n                return toCharSet(char.elements, flags).isEmpty;\n            }\n        }\n    }\n}\n","import { isStrictBackreference, isEmptyBackreference } from \"./basic\";\nimport { assertNever } from \"./util\";\n/**\n * Returns whether two nodes are structurally equivalent.\n *\n * If two elements are structurally equivalent, they must also semantically equivalent. However, two semantically\n * equivalent elements might not be structurally equivalent (e.g. `/[ab]/` !=<sub>struct</sub> `/[ba]/`).\n */\nexport function structurallyEqual(x, y) {\n    if (x == y) {\n        return true;\n    }\n    if (!x || !y || x.type != y.type) {\n        return false;\n    }\n    switch (x.type) {\n        case \"Alternative\": {\n            const other = y;\n            return manyAreStructurallyEqual(x.elements, other.elements);\n        }\n        case \"Assertion\": {\n            const other = y;\n            if (x.kind === other.kind) {\n                if (x.kind === \"lookahead\" || x.kind === \"lookbehind\") {\n                    const otherLookaround = y;\n                    return (x.negate === otherLookaround.negate &&\n                        manyAreStructurallyEqual(x.alternatives, otherLookaround.alternatives));\n                }\n                else {\n                    return x.raw === other.raw;\n                }\n            }\n            return false;\n        }\n        case \"Backreference\": {\n            const other = y;\n            if (isEmptyBackreference(x)) {\n                return isEmptyBackreference(other);\n            }\n            else {\n                return (structurallyEqual(x.resolved, other.resolved) &&\n                    isStrictBackreference(x) == isStrictBackreference(other));\n            }\n        }\n        case \"Character\": {\n            const other = y;\n            return x.value === other.value;\n        }\n        case \"CharacterClass\": {\n            const other = y;\n            return x.negate === other.negate && manyAreStructurallyEqual(x.elements, other.elements);\n        }\n        case \"CharacterClassRange\": {\n            const other = y;\n            return structurallyEqual(x.min, other.min) && structurallyEqual(x.max, other.max);\n        }\n        case \"CharacterSet\": {\n            const other = y;\n            if (x.kind === \"property\" && other.kind === \"property\") {\n                return x.negate === other.negate && x.key === other.key;\n            }\n            else {\n                return x.raw === other.raw;\n            }\n        }\n        case \"Flags\": {\n            const other = y;\n            return (x.dotAll === other.dotAll &&\n                x.global === other.global &&\n                x.ignoreCase === other.ignoreCase &&\n                x.multiline === other.multiline &&\n                x.sticky === other.sticky &&\n                x.unicode === other.unicode);\n        }\n        case \"CapturingGroup\":\n        case \"Group\":\n        case \"Pattern\": {\n            const other = y;\n            return manyAreStructurallyEqual(x.alternatives, other.alternatives);\n        }\n        case \"Quantifier\": {\n            const other = y;\n            return (x.min === other.min &&\n                x.max === other.max &&\n                x.greedy === other.greedy &&\n                structurallyEqual(x.element, other.element));\n        }\n        case \"RegExpLiteral\": {\n            const other = y;\n            return structurallyEqual(x.flags, other.flags) && structurallyEqual(x.pattern, other.pattern);\n        }\n        default:\n            throw assertNever(x);\n    }\n}\nfunction manyAreStructurallyEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (!structurallyEqual(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n","import { getMatchingDirectionFromAssertionKind, getMatchingDirection } from \"./basic\";\nimport { assertNever } from \"./util\";\n/**\n * This function goes to all elements reachable from the given `start` element.\n *\n * ## Paths\n *\n * The function uses _paths_. A path is an [execution path](https://en.wikipedia.org/wiki/Symbolic_execution) that\n * describes a sequence of regex elements.\n *\n * I.e. there are two paths to go from `a` to `b` in the pattern `/a(\\w|dd)b/`. The first path is `a \\w b` and the\n * second path is `a d d b`.\n *\n * However, the problem with paths is that there can be exponentially many because of combinatorial explosion (e.g. the\n * pattern `/(a|b)(a|b)(a|b)(a|b)(a|b)/` has 32 paths). To solve this problem, paths can be _joined_ together again.\n *\n * I.e. in the pattern `/a(\\w|dd)b/`, first element of all paths will be `a`. After `a`, the path splits into two. We\n * call each of the split paths a _fork_. The two forks will be `a ( \\w` and `a ( d d`. The `(` is used to indicate that\n * a fork was made. Since both paths come together after the group ends, they will be _joined_. The joined path of\n * `a ( \\w` and `a ( d d` will be written as `a ( \\w | d d )`. The `)` is used to indicate that forks have been joined.\n * The final path will be `a ( \\w | d d ) b`.\n *\n * This method of forking and joining works for alternations but it won't work for quantifiers. This is why quantifiers\n * will be treated as single elements that can be entered. By default, a quantifier `q` will be interpreted as `( q | )`\n * if its minimum is zero and as `( q )` otherwise.\n *\n * I.e. in the pattern `/ab*c/`, the paths are `a ( b* | ) c`, and in `/ab+c/`, the path is `a b+ c`.\n *\n * ### State\n *\n * Paths are thought of as a sequence of elements and they are represented by state (type parameter `S`). All operations\n * that fork, join, or assert paths will operate on state and not a sequence of elements.\n *\n * State allows operations to be implemented more efficiently and ensures that only necessary data is passed around.\n * An analysis of paths usually tracks properties and analyses how these properties change, the current value of these\n * properties is state.\n *\n * ## Operations\n *\n * Operations act upon state and are specific to the type of state. They define how state changes when\n * entering/leaving/asserting elements and how paths fork, join, and continue.\n *\n * ### Operation sequence\n *\n * To follow all paths, two methods are necessary: one method that enters elements and one that determines the next\n * element. These methods will be called `Enter` and `Next` respectively. These methods will call the given operations\n * roughly like this:\n *\n * ```text\n * function Enter(element, state):\n *     operations.enter\n *     if operations.continueInto:\n *         if element.type == GROUP:\n *             operations.join(\n *                 element.alternatives.map(e => Enter(e, operations.fork(state)))\n *             )\n *         if element.type == QUANTIFIER:\n *             if element.max == 0:\n *                 // do nothing\n *             else if element.min == 0:\n *                 operations.join([\n *                     state,\n *                     Enter(quantifier, operations.fork(state))\n *                 ])\n *             else:\n *                 Enter(quantifier, operations.fork(state))\n *         if element.type == LOOKAROUND:\n *             operations.assert(\n *                 state,\n *                 operations.join(\n *                     element.alternatives.map(e => Enter(e, operations.fork(state)))\n *                 )\n *             )\n *     operations.leave\n *     Next(element, state)\n *\n * function Next(element, state):\n *     if operations.continueAfter:\n *         if noNextElement:\n *             operations.endPath\n *         else:\n *             Enter(nextElement, state)\n * ```\n *\n * (This is just simplified pseudo code but the general order of operations will be the same.)\n *\n * ## Runtime\n *\n * If `n` elements can be reached from the given starting element, then the average runtime will be `O(n)` and the\n * worst-case runtime will be `O(n^2)`.\n *\n * @param start\n * @param startMode If \"enter\", then the first element to be entered will be the starting element. If \"leave\", then the\n * first element to continue after will be the starting element.\n * @param initialState\n * @param operations\n * @param direction The direction in which paths will be followed. If undefined, then the natural matching direction\n * ({@link getMatchingDirection}) of the start element will be used.\n *\n * @typeParam S The type of the state.\n */\nexport function followPaths(start, startMode, initialState, operations, direction) {\n    function opEnter(element, state, direction) {\n        var _a, _b;\n        if (operations.enter) {\n            state = operations.enter(element, state, direction);\n        }\n        const continueInto = (_b = (_a = operations.continueInto) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;\n        if (continueInto) {\n            switch (element.type) {\n                case \"Assertion\": {\n                    if (element.kind === \"lookahead\" || element.kind === \"lookbehind\") {\n                        const assertionDirection = getMatchingDirectionFromAssertionKind(element.kind);\n                        const assertion = operations.join(element.alternatives.map(a => enterAlternative(a, doFork(operations, state, direction), assertionDirection)), assertionDirection);\n                        state = endPath(state, assertionDirection, \"assertion\");\n                        if (operations.assert) {\n                            state = operations.assert(state, direction, assertion, assertionDirection);\n                        }\n                    }\n                    break;\n                }\n                case \"Group\":\n                case \"CapturingGroup\": {\n                    state = operations.join(element.alternatives.map(a => enterAlternative(a, doFork(operations, state, direction), direction)), direction);\n                    break;\n                }\n                case \"Quantifier\": {\n                    if (element.max === 0) {\n                        // do nothing\n                    }\n                    else if (element.min === 0) {\n                        state = operations.join([state, opEnter(element.element, doFork(operations, state, direction), direction)], direction);\n                    }\n                    else {\n                        state = opEnter(element.element, state, direction);\n                    }\n                    break;\n                }\n            }\n        }\n        if (operations.leave) {\n            state = operations.leave(element, state, direction);\n        }\n        return state;\n    }\n    function enterAlternative(alternative, state, direction) {\n        var _a, _b;\n        let i = direction === \"ltr\" ? 0 : alternative.elements.length - 1;\n        const increment = direction === \"ltr\" ? +1 : -1;\n        let element;\n        for (; (element = alternative.elements[i]); i += increment) {\n            state = opEnter(element, state, direction);\n            const continueAfter = (_b = (_a = operations.continueAfter) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;\n            if (!continueAfter) {\n                break;\n            }\n        }\n        return state;\n    }\n    function opNext(element, state, direction) {\n        for (;;) {\n            let after = getNextElement(element, state, direction);\n            while (Array.isArray(after)) {\n                const [quant, other] = after;\n                state = operations.join([state, opEnter(quant, doFork(operations, state, direction), direction)], direction);\n                after = other;\n            }\n            if (after === false) {\n                return state;\n            }\n            else if (after === \"assertion\" || after === \"pattern\") {\n                return endPath(state, direction, after);\n            }\n            else {\n                state = opEnter(after, state, direction);\n                element = after;\n            }\n        }\n    }\n    function getNextElement(element, state, direction) {\n        var _a, _b;\n        const parent = element.parent;\n        if (parent.type === \"CharacterClass\" || parent.type === \"CharacterClassRange\") {\n            throw new Error(\"The given element cannot be part of a character class.\");\n        }\n        const continuePath = (_b = (_a = operations.continueAfter) === null || _a === void 0 ? void 0 : _a.call(operations, element, state, direction)) !== null && _b !== void 0 ? _b : true;\n        if (!continuePath) {\n            return false;\n        }\n        if (parent.type === \"Quantifier\") {\n            // This is difficult.\n            // The main problem is that paths coming out of the quantifier might loop back into itself. This means that\n            // we have to consider the path that leaves the quantifier and the path that goes back into the quantifier.\n            if (parent.max <= 1) {\n                // Can't loop, so we only have to consider the path going out of the quantifier.\n                return getNextElement(parent, state, direction);\n            }\n            else {\n                return [parent, getNextElement(parent, state, direction)];\n            }\n        }\n        else {\n            const nextIndex = parent.elements.indexOf(element) + (direction === \"ltr\" ? +1 : -1);\n            const nextElement = parent.elements[nextIndex];\n            if (nextElement) {\n                return nextElement;\n            }\n            else {\n                const parentParent = parent.parent;\n                if (parentParent.type === \"Pattern\") {\n                    return \"pattern\";\n                }\n                else if (parentParent.type === \"Assertion\") {\n                    if (continueOutside(parentParent, state, direction)) {\n                        return getNextElement(parentParent, state, direction);\n                    }\n                    return \"assertion\";\n                }\n                else if (parentParent.type === \"CapturingGroup\" || parentParent.type === \"Group\") {\n                    return getNextElement(parentParent, state, direction);\n                }\n                throw assertNever(parentParent);\n            }\n        }\n    }\n    function continueOutside(assertion, state, direction) {\n        if (operations.continueOutside) {\n            return operations.continueOutside(assertion, state, direction);\n        }\n        return false;\n    }\n    function endPath(state, direction, reason) {\n        if (operations.endPath) {\n            return operations.endPath(state, direction, reason);\n        }\n        return state;\n    }\n    if (!direction) {\n        direction = getMatchingDirection(start);\n    }\n    if (start.type === \"Alternative\") {\n        // Alternatives are a little tricky.\n        // The basic ideas are the following:\n        //  1) If we want to *enter* an alternative, we can just enter its first element instead.\n        //  2) If we want to *leave* an alternative, we can leave its parent element instead.\n        //     This gets more complex because the parent might be an assertion or the pattern.\n        if (start.elements.length === 0) {\n            // For empty alternatives, entering is the same as leaving\n            startMode = \"next\";\n        }\n        if (startMode === \"enter\") {\n            start = getFirstElement(start, direction);\n        }\n        else {\n            const parent = start.parent;\n            if (parent.type === \"Pattern\") {\n                return endPath(initialState, direction, \"pattern\");\n            }\n            else if (parent.type === \"Assertion\" && !continueOutside(parent, initialState, direction)) {\n                return endPath(initialState, direction, \"assertion\");\n            }\n            start = parent;\n        }\n    }\n    if (startMode === \"enter\") {\n        initialState = opEnter(start, initialState, direction);\n    }\n    return opNext(start, initialState, direction);\n}\nfunction doFork(operations, state, direction) {\n    if (operations.fork) {\n        return operations.fork(state, direction);\n    }\n    else {\n        return state;\n    }\n}\nfunction getFirstElement(a, dir) {\n    if (dir === \"ltr\") {\n        return a.elements[0];\n    }\n    else {\n        return a.elements[a.elements.length - 1];\n    }\n}\n","import { CharSet } from \"refa\";\nimport { getMatchingDirectionFromAssertionKind, isStrictBackreference, getLengthRange, hasSomeDescendant, isEmptyBackreference, invertMatchingDirection, } from \"./basic\";\nimport { toCharSet } from \"./to-char-set\";\nimport { followPaths } from \"./follow\";\nimport { assertNever, CharUnion, intersectInexact, isReadonlyArray, unionInexact } from \"./util\";\nimport { Chars } from \"./chars\";\nimport { CacheInstance } from \"./cache\";\n/**\n * This namespace contains methods for working with {@link FirstLookChar}s.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport var FirstLookChars;\n(function (FirstLookChars) {\n    /**\n     * Returns a {@link FirstLookChar} that is equivalent to a trivially accepting lookaround.\n     *\n     * The returned look is semantically equivalent to `(?=)` == `(?=[^]|$)` or `(?<=)` == `(?<=[^]|^)`.\n     */\n    function all(flags) {\n        return {\n            char: Chars.all(flags),\n            exact: true,\n            edge: true,\n        };\n    }\n    FirstLookChars.all = all;\n    /**\n     * Returns a {@link FirstLookChar} that is equivalent to an assertion that only accepts the start/end of the input\n     * string.\n     *\n     * The returned look is semantically equivalent to `$` == `(?=[]|$)` or `^` == `(?<=[]|^)`.\n     */\n    function edge(flags) {\n        return {\n            char: Chars.empty(flags),\n            exact: true,\n            edge: true,\n        };\n    }\n    FirstLookChars.edge = edge;\n    /**\n     * Converts the given {@link FirstLookChar} to a {@link FirstConsumedChar}.\n     *\n     * This is semantically equivalent to `(?=b|$)` -> `[]|(?=b|$)`.\n     *\n     * Note: This operation will typically return a {@link FirstPartiallyConsumedChar}. It will only return a\n     * {@link FirstFullyConsumedChar} if the given `char` is empty and `edge: false`. This is because\n     * `(?=[])` -> `[]|(?=[])` == `[]`.\n     */\n    function toConsumed(look) {\n        if (!look.edge && look.char.isEmpty) {\n            // the given look trivially rejects everything\n            return {\n                char: CharSet.empty(look.char.maximum),\n                exact: true,\n                empty: false,\n            };\n        }\n        else {\n            return {\n                char: CharSet.empty(look.char.maximum),\n                exact: true,\n                empty: true,\n                look,\n            };\n        }\n    }\n    FirstLookChars.toConsumed = toConsumed;\n})(FirstLookChars || (FirstLookChars = {}));\n/**\n * This namespace contains methods for working with {@link FirstConsumedChar}s.\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport var FirstConsumedChars;\n(function (FirstConsumedChars) {\n    /**\n     * Returns a {@link FirstConsumedChar} that is equivalent to the empty concatenation.\n     */\n    function emptyConcat(flags) {\n        return {\n            char: Chars.empty(flags),\n            exact: true,\n            empty: true,\n            look: FirstLookChars.all(flags),\n        };\n    }\n    FirstConsumedChars.emptyConcat = emptyConcat;\n    /**\n     * Returns a {@link FirstConsumedChar} that is equivalent to the empty union (or empty set).\n     */\n    function emptyUnion(flags) {\n        return {\n            char: Chars.empty(flags),\n            exact: true,\n            empty: false,\n        };\n    }\n    FirstConsumedChars.emptyUnion = emptyUnion;\n    /**\n     * Converts the given {@link FirstConsumedChar} to a {@link FirstLookChar}.\n     *\n     * This is conceptually equivalent to wrapping the given consumed character into a lookaround.\n     *\n     * This is semantically equivalent to `a|(?=b|$)` -> `(?=a|(?=b|$))` == `(?=[ab]|$)`.\n     */\n    function toLook(consumed) {\n        if (consumed.empty) {\n            // We have 2 cases:\n            //   (1) (?=a|(?=b))\n            //       (?=a|b)\n            //       (?=[ab])\n            //   (2) (?=a|(?=b|$))\n            //       (?=a|b|$)\n            //       (?=[ab]|$)\n            const union = unionInexact(consumed, consumed.look);\n            return {\n                char: union.char,\n                exact: union.exact,\n                edge: consumed.look.edge,\n            };\n        }\n        else {\n            // It's already in the correct form:\n            //   (?=a)\n            return {\n                char: consumed.char,\n                exact: consumed.exact,\n                edge: false,\n            };\n        }\n    }\n    FirstConsumedChars.toLook = toLook;\n    /**\n     * Creates the union of all the given {@link FirstConsumedChar}s.\n     *\n     * The result is independent of the order in which the characters are given.\n     */\n    function union(chars, flags) {\n        const union = CharUnion.fromFlags(flags);\n        const looks = [];\n        for (const itemChar of chars) {\n            union.add(itemChar);\n            if (itemChar.empty) {\n                looks.push(itemChar.look);\n            }\n        }\n        if (looks.length > 0) {\n            if (looks.length === 1) {\n                return {\n                    char: union.char,\n                    exact: union.exact,\n                    empty: true,\n                    look: looks[0],\n                };\n            }\n            // This means that the unioned elements look something like this:\n            //   (a|(?=g)|b?|x)\n            //\n            // Adding the trivially accepting look after all all alternatives that can be empty, we'll get:\n            //   (a|(?=g)|b?|x)\n            //   (a|(?=g)|b?(?=[^]|$)|x)\n            //   (a|(?=g)|b(?=[^]|$)|(?=[^]|$)|x)\n            //\n            // Since we are only interested in the first character, the look in `b(?=[^]|$)` can be removed.\n            //   (a|(?=g)|b|(?=[^]|$)|x)\n            //   (a|b|x|(?=g)|(?=[^]|$))\n            //   ([abx]|(?=g)|(?=[^]|$))\n            //\n            // To union the looks, we can simply use the fact that `(?=a)|(?=b)` == `(?=a|b)`\n            //   ([abx]|(?=g)|(?=[^]|$))\n            //   ([abx]|(?=g|[^]|$))\n            //   ([abx]|(?=[^]|$))\n            //\n            // And with that we are done. This is exactly the form of a first partial char. Getting the exactness of the\n            // union of normal chars and look chars follows the same rules.\n            const lookUnion = CharUnion.fromFlags(flags);\n            let edge = false;\n            for (const look of looks) {\n                lookUnion.add(look);\n                edge = edge || look.edge;\n            }\n            return {\n                char: union.char,\n                exact: union.exact,\n                empty: true,\n                look: { char: lookUnion.char, exact: lookUnion.exact, edge },\n            };\n        }\n        else {\n            return { char: union.char, exact: union.exact, empty: false };\n        }\n    }\n    FirstConsumedChars.union = union;\n    /**\n     * Creates the concatenation of all the given {@link FirstConsumedChar}s.\n     *\n     * The given char iterable is evaluated **lazily**. The implementation will try to iterate as few chars as possible.\n     */\n    function concat(chars, flags) {\n        const union = CharUnion.fromFlags(flags);\n        let look = FirstLookChars.all(flags);\n        for (const item of chars) {\n            union.add(intersectInexact(item, look));\n            if (item.empty) {\n                // This is the hard case. We need to convert the expression\n                //   (a|(?=b))(c|(?=d))\n                // into an expression\n                //   e|(?=f)\n                // (we will completely ignore edge assertions for now)\n                //\n                // To do that, we'll use the following idea:\n                //   (a|(?=b))(c|(?=d))\n                //   a(c|(?=d))|(?=b)(c|(?=d))\n                //   ac|a(?=d)|(?=b)c|(?=b)(?=d)\n                //\n                // Since we are only interested in the first char, we can remove the `c` in `ac` and the `(?=d)` in\n                // `a(?=d)`. Furthermore, `(?=b)c` is a single char, so let's call it `C` for now.\n                //   ac|a(?=d)|(?=b)c|(?=b)(?=d)\n                //   a|a|C|(?=b)(?=d)\n                //   [aC]|(?=b)(?=d)\n                //   [aC]|(?=(?=b)d)\n                //\n                // This is *almost* the desired form. We now have to convert `(?=(?=b)d)` to an expression of the form\n                // `(?=f)`. This is the point where we can't ignore edge assertions any longer. Let's look at all possible\n                // cases and see how it plays out. Also, let `D` be the char intersection of `b` and `d`.\n                //   (1) (?=(?=b)d)\n                //       (?=D)\n                //\n                //   (2) (?=(?=b)(d|$))\n                //       (?=(?=b)d|(?=b)$)\n                //       (?=D)\n                //\n                //   (3) (?=(?=b|$)d)\n                //       (?=((?=b)|$)d)\n                //       (?=(?=b)d|$d)\n                //       (?=D)\n                //\n                //   (4) (?=(?=b|$)(d|$))\n                //       (?=((?=b)|$)(d|$))\n                //       (?=(?=b)(d|$)|$(d|$))\n                //       (?=(?=b)d|(?=b)$|$d|$$)\n                //       (?=D|$)\n                //\n                // As we can see, the look char is always `D` and the edge is only accepted if it's accepted by both.\n                const lookIntersection = intersectInexact(look, item.look);\n                look = {\n                    char: lookIntersection.char,\n                    exact: lookIntersection.exact,\n                    edge: look.edge && item.look.edge,\n                };\n                if (!look.edge && look.char.isEmpty) {\n                    // The look trivially rejects everything\n                    return { char: union.char, exact: union.exact, empty: false };\n                }\n            }\n            else {\n                return { char: union.char, exact: union.exact, empty: false };\n            }\n        }\n        return { char: union.char, exact: union.exact, empty: true, look };\n    }\n    FirstConsumedChars.concat = concat;\n    /**\n     * Makes the given consumed character optional.\n     *\n     * This is semantically equivalent to `a|(?=b|$)` -> `a?`.\n     */\n    function makeOptional(consumed) {\n        return {\n            char: consumed.char,\n            exact: consumed.exact,\n            empty: true,\n            look: { char: CharSet.all(consumed.char.maximum), exact: true, edge: true },\n        };\n    }\n    FirstConsumedChars.makeOptional = makeOptional;\n})(FirstConsumedChars || (FirstConsumedChars = {}));\nclass ImplOptions {\n    constructor(flags) {\n        this._currentWordBoundaries = [];\n        // We need a cache to avoid an exponential worst case regarding boundary assertions.\n        // If the current flags are a cache instance, we'll use the cache from there and if not, then we'll create a\n        // new cache.\n        if (flags instanceof CacheInstance) {\n            this._ltrCache = flags.getFirstConsumedCharLTR;\n            this._rtlCache = flags.getFirstConsumedCharRTL;\n        }\n        else {\n            this._ltrCache = new WeakMap();\n            this._rtlCache = new WeakMap();\n        }\n    }\n    isCurrentWordBoundary(element) {\n        return this._currentWordBoundaries.some(e => e === element);\n    }\n    pushWordBoundary(element) {\n        this._currentWordBoundaries.push(element);\n    }\n    popWordBoundary() {\n        this._currentWordBoundaries.pop();\n    }\n    getCached(element, dir) {\n        if (dir === \"ltr\") {\n            return this._ltrCache.get(element);\n        }\n        else {\n            return this._rtlCache.get(element);\n        }\n    }\n    setCached(element, dir, result) {\n        if (dir === \"ltr\") {\n            this._ltrCache.set(element, result);\n        }\n        else {\n            this._rtlCache.set(element, result);\n        }\n    }\n}\n/**\n * If a character is returned, it guaranteed to be a super set of the actual character. If the given element is\n * always of zero length, then the empty character set will be returned.\n *\n * If `exact` is `true` then it is guaranteed that the returned character is guaranteed to be the actual\n * character at all times if this element is not influenced by lookarounds outside itself.\n *\n * ## Partially consumed\n *\n * Only the given element and its children are processed. This is important when considering partially consumed first\n * characters. The lookaround is derived only from the assertions inside the given element.\n *\n * E.g. In `/b?a/`, the result for `b?` is `{ char: 'b', empty: true, look: { char: all, edge: true } }`. The\n * lookaround accepts all characters because it doesn't take the `a` after `b?` into consideration.\n */\nexport function getFirstConsumedChar(element, direction, flags) {\n    const options = new ImplOptions(flags);\n    if (isReadonlyArray(element)) {\n        return getFirstConsumedCharAlternativesImpl(element, direction, flags, options);\n    }\n    else {\n        return getFirstConsumedCharImpl(element, direction, flags, options);\n    }\n}\nfunction getFirstConsumedCharAlternativesImpl(alternatives, direction, flags, options) {\n    return FirstConsumedChars.union(alternatives.map(e => getFirstConsumedCharImpl(e, direction, flags, options)), flags);\n}\nfunction getFirstConsumedCharImpl(element, direction, flags, options) {\n    let result = options.getCached(element, direction);\n    if (result === undefined) {\n        result = getFirstConsumedCharUncachedImpl(element, direction, flags, options);\n        options.setCached(element, direction, result);\n    }\n    return result;\n}\nfunction getFirstConsumedCharAssertionImpl(element, direction, flags, options) {\n    switch (element.kind) {\n        case \"word\":\n            if (options.isCurrentWordBoundary(element)) {\n                // this means that the value of a word boundary assertion depends on itself indirectly.\n                // we have to stop the recursion here because infinite recursion is possible otherwise.\n                return misdirectedAssertion();\n            }\n            else {\n                options.pushWordBoundary(element);\n                const before = getFirstCharAfterImpl(element, invertMatchingDirection(direction), flags, options);\n                options.popWordBoundary();\n                // Remember:\n                //   \\B == (?<=\\w)(?=\\w)|(?<!\\w)(?!\\w)\n                //   \\b == (?<!\\w)(?=\\w)|(?<=\\w)(?!\\w)\n                const word = Chars.word(flags);\n                if (before.edge) {\n                    // this forces our hand a little. Since the previous \"character\" might be the start/end of\n                    // the string, we have to enter the alternative that starts with `(?<!\\w)`\n                    if (before.char.isDisjointWith(word)) {\n                        return wordAssertion(element.negate);\n                    }\n                    else {\n                        // it might be either of the alternatives\n                        return misdirectedAssertion();\n                    }\n                }\n                else {\n                    if (before.char.isDisjointWith(word)) {\n                        return wordAssertion(element.negate);\n                    }\n                    else if (before.char.isSubsetOf(word)) {\n                        return wordAssertion(!element.negate);\n                    }\n                    else {\n                        // it might be either of the alternatives\n                        return misdirectedAssertion();\n                    }\n                }\n            }\n        case \"end\":\n        case \"start\":\n            if (getMatchingDirectionFromAssertionKind(element.kind) === direction) {\n                if (flags.multiline) {\n                    return lineAssertion();\n                }\n                else {\n                    return edgeAssertion();\n                }\n            }\n            else {\n                return misdirectedAssertion();\n            }\n        case \"lookahead\":\n        case \"lookbehind\":\n            if (getMatchingDirectionFromAssertionKind(element.kind) === direction) {\n                if (element.negate) {\n                    // A little note about negative:\n                    //\n                    // Negation is hard because it throws the idea of exactness on its heads. The interface defines\n                    // exactness in a way that means: \"we only guarantee that the returned characters are a superset of\n                    // the actual (=correct) characters.\" Negation is incompatible with that definition of exactness\n                    // because negating a _superset_ means that we can only guarantee a _subset_. So we can only do\n                    // _exact_ negation. This is a big limitation.\n                    //\n                    // So what negations can be done _exactly_?\n                    // Single-character negations, e.g. `(?!a)` or `(?!a|b|\\d)`. That's it. All other negated assertions\n                    // are not doable _in general_.\n                    if (hasSomeDescendant(element, d => d !== element && d.type === \"Assertion\")) {\n                        return misdirectedAssertion();\n                    }\n                    const firstChar = getFirstConsumedCharAlternativesImpl(element.alternatives, direction, flags, options);\n                    const range = getLengthRange(element.alternatives);\n                    if (firstChar.empty || !range) {\n                        // trivially rejecting\n                        return { char: Chars.empty(flags), empty: false, exact: true };\n                    }\n                    if (!firstChar.exact || range.max !== 1) {\n                        // the goal to to convert `(?![a])` to `(?=[^a]|$)` but this negation is only correct\n                        // if the characters are exact and if the assertion asserts at most one character\n                        // E.g. `(?![a][b])` == `(?=$|[^a]|[a][^b])`\n                        return misdirectedAssertion();\n                    }\n                    else {\n                        return FirstLookChars.toConsumed({ char: firstChar.char.negate(), edge: true, exact: true });\n                    }\n                }\n                else {\n                    const firstChar = getFirstConsumedCharAlternativesImpl(element.alternatives, direction, flags, options);\n                    return FirstLookChars.toConsumed(FirstConsumedChars.toLook(firstChar));\n                }\n            }\n            else {\n                return misdirectedAssertion();\n            }\n        default:\n            throw assertNever(element);\n    }\n    /**\n     * The result for an assertion that (partly) assert for the wrong matching direction.\n     */\n    function misdirectedAssertion() {\n        return FirstLookChars.toConsumed({\n            char: Chars.all(flags),\n            edge: true,\n            // This is the important part.\n            // Since the allowed chars depend on the previous chars, we don't know which will be allowed.\n            exact: false,\n        });\n    }\n    function edgeAssertion() {\n        return FirstLookChars.toConsumed(FirstLookChars.edge(flags));\n    }\n    function lineAssertion() {\n        return FirstLookChars.toConsumed({\n            char: Chars.lineTerminator(flags),\n            edge: true,\n            exact: true,\n        });\n    }\n    function wordAssertion(negate) {\n        const word = Chars.word(flags);\n        return FirstLookChars.toConsumed({\n            char: negate ? word.negate() : word,\n            edge: negate,\n            exact: true,\n        });\n    }\n}\nfunction getFirstConsumedCharUncachedImpl(element, direction, flags, options) {\n    switch (element.type) {\n        case \"Assertion\":\n            return getFirstConsumedCharAssertionImpl(element, direction, flags, options);\n        case \"Character\":\n        case \"CharacterSet\":\n        case \"CharacterClass\":\n            return { char: toCharSet(element, flags), empty: false, exact: true };\n        case \"Quantifier\": {\n            if (element.max === 0) {\n                return FirstConsumedChars.emptyConcat(flags);\n            }\n            const firstChar = getFirstConsumedCharImpl(element.element, direction, flags, options);\n            if (element.min === 0) {\n                return FirstConsumedChars.makeOptional(firstChar);\n            }\n            else {\n                return firstChar;\n            }\n        }\n        case \"Alternative\": {\n            let elements = element.elements;\n            if (direction === \"rtl\") {\n                elements = [...elements];\n                elements.reverse();\n            }\n            return FirstConsumedChars.concat((function* () {\n                for (const e of elements) {\n                    yield getFirstConsumedCharImpl(e, direction, flags, options);\n                }\n            })(), flags);\n        }\n        case \"CapturingGroup\":\n        case \"Group\":\n            return getFirstConsumedCharAlternativesImpl(element.alternatives, direction, flags, options);\n        case \"Backreference\": {\n            if (isEmptyBackreference(element)) {\n                return FirstConsumedChars.emptyConcat(flags);\n            }\n            let resolvedChar = getFirstConsumedCharImpl(element.resolved, direction, flags, options);\n            // the resolved character is only exact if it is only a single character.\n            // i.e. /(\\w)\\1/ here the (\\w) will capture exactly any word character, but the \\1 can only match\n            // one word character and that is the only (\\w) matched.\n            if (resolvedChar.exact && resolvedChar.char.size > 1) {\n                resolvedChar = Object.assign(Object.assign({}, resolvedChar), { exact: false });\n            }\n            if (isStrictBackreference(element)) {\n                return resolvedChar;\n            }\n            else {\n                // there is at least one path through which the backreference will (possibly) be replaced with the\n                // empty string\n                return FirstConsumedChars.makeOptional(resolvedChar);\n            }\n        }\n        default:\n            throw assertNever(element);\n    }\n}\nexport function getFirstConsumedCharAfter(afterThis, direction, flags) {\n    return getFirstConsumedCharAfterImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstConsumedCharAfterImpl(afterThis, direction, flags, options) {\n    const result = followPaths(afterThis, \"next\", FirstConsumedChars.emptyConcat(flags), {\n        join(states) {\n            return FirstConsumedChars.union(states, flags);\n        },\n        enter(element, state, direction) {\n            const first = getFirstConsumedCharImpl(element, direction, flags, options);\n            return FirstConsumedChars.concat([state, first], flags);\n        },\n        continueInto() {\n            return false;\n        },\n        continueAfter(_, state) {\n            return state.empty;\n        },\n        continueOutside(element, _, direction) {\n            return getMatchingDirectionFromAssertionKind(element.kind) !== direction;\n        },\n    }, direction);\n    return result;\n}\n/**\n * Returns the first character after the given element.\n *\n * What \"after\" means depends the on the given direction which will be interpreted as the current matching\n * direction. You can use this to get the previous character of an element as well.\n */\nexport function getFirstCharAfter(afterThis, direction, flags) {\n    return getFirstCharAfterImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstCharAfterImpl(afterThis, direction, flags, options) {\n    return FirstConsumedChars.toLook(getFirstConsumedCharAfterImpl(afterThis, direction, flags, options));\n}\n/**\n * This function behaves exactly like {@link getFirstConsumedCharAfter} but it also tracks what elements contribute to\n * the result.\n */\nexport function getFirstConsumedCharAfterWithContributors(afterThis, direction, flags) {\n    return getFirstConsumedCharAfterWithContributorsImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstConsumedCharAfterWithContributorsImpl(afterThis, direction, flags, option) {\n    const result = followPaths(afterThis, \"next\", { char: FirstConsumedChars.emptyConcat(flags), contributors: [] }, {\n        join(states) {\n            const contributors = new Set();\n            states.forEach(s => s.contributors.forEach(e => contributors.add(e)));\n            return {\n                char: FirstConsumedChars.union(states.map(s => s.char), flags),\n                contributors: [...contributors],\n            };\n        },\n        enter(element, state, direction) {\n            const first = getFirstConsumedCharImpl(element, direction, flags, option);\n            return {\n                char: FirstConsumedChars.concat([state.char, first], flags),\n                contributors: [...state.contributors, element],\n            };\n        },\n        continueInto() {\n            return false;\n        },\n        continueAfter(_, state) {\n            return state.char.empty;\n        },\n        continueOutside(element, _, direction) {\n            return getMatchingDirectionFromAssertionKind(element.kind) !== direction;\n        },\n    }, direction);\n    return result;\n}\n/**\n * This function behaves exactly like {@link getFirstCharAfter} but it also tracks what elements contribute to the\n * result.\n */\nexport function getFirstCharAfterWithContributors(afterThis, direction, flags) {\n    return getFirstCharAfterWithContributorsImpl(afterThis, direction, flags, new ImplOptions(flags));\n}\nfunction getFirstCharAfterWithContributorsImpl(afterThis, direction, flags, option) {\n    const { char, contributors } = getFirstConsumedCharAfterWithContributorsImpl(afterThis, direction, flags, option);\n    return { char: FirstConsumedChars.toLook(char), contributors };\n}\n","import { isEmptyBackreference, isLengthRangeMinZero, isStrictBackreference, isZeroLength, } from \"./basic\";\nimport { CacheInstance } from \"./cache\";\nimport { FirstConsumedChars, getFirstCharAfter, getFirstConsumedChar, getFirstConsumedCharAfter, } from \"./next-char\";\nimport { toCharSet } from \"./to-char-set\";\nimport { assertNever } from \"./util\";\n/**\n * Returns the longest knowable prefix guaranteed to always be accepted by the\n * given alternative (ignoring assertions).\n *\n * All character sets except the last one are guaranteed to be non-empty. The\n * last character set is only guaranteed to be non-empty if `includeAfter: false`.\n */\nexport function getLongestPrefix(alternative, direction, flags, options = {}) {\n    const cacheInstance = CacheInstance.from(flags);\n    flags = cacheInstance;\n    const { includeAfter = false, onlyInside = false, looseGroups = false } = options;\n    const cache = cacheInstance.getLongestPrefix;\n    const cacheKey = `${direction},${includeAfter},${onlyInside},${looseGroups}`;\n    let weakCache = cache.get(cacheKey);\n    if (weakCache === undefined) {\n        weakCache = new WeakMap();\n        cache.set(cacheKey, weakCache);\n    }\n    let cached = weakCache.get(alternative);\n    if (cached === undefined) {\n        cached = getLongestPrefixImpl(alternative, direction, { includeAfter, onlyInside, looseGroups, root: alternative }, flags);\n        weakCache.set(alternative, cached);\n    }\n    return cached;\n}\nfunction getLongestPrefixImpl(alternative, direction, options, flags) {\n    const { chars, complete } = getAlternativePrefix(alternative, direction, options, flags);\n    // try to find empty character sets\n    for (let i = 0; i < chars.length; i++) {\n        if (chars[i].isEmpty) {\n            return chars.slice(0, i);\n        }\n    }\n    // append the next character after the alternative\n    if (complete && options.includeAfter && !options.onlyInside) {\n        chars.push(getFirstCharAfterAlternative(alternative, direction, flags).char);\n    }\n    return chars;\n}\nconst EMPTY_COMPLETE = { chars: [], complete: true };\nconst EMPTY_INCOMPLETE = { chars: [], complete: false };\nfunction getAlternativePrefix(alternative, direction, options, flags) {\n    const { elements } = alternative;\n    const chars = [];\n    const first = direction === \"ltr\" ? 0 : elements.length - 1;\n    const inc = direction === \"ltr\" ? +1 : -1;\n    for (let i = first; i >= 0 && i < elements.length; i += inc) {\n        const inner = getElementPrefix(elements[i], direction, options, flags);\n        chars.push(...inner.chars);\n        if (!inner.complete) {\n            return { chars, complete: false };\n        }\n    }\n    return { chars, complete: true };\n}\nfunction getElementPrefix(element, direction, options, flags) {\n    switch (element.type) {\n        case \"Assertion\":\n            return EMPTY_COMPLETE;\n        case \"Character\":\n        case \"CharacterClass\":\n        case \"CharacterSet\":\n            return {\n                chars: [toCharSet(element, flags)],\n                complete: true,\n            };\n        case \"CapturingGroup\":\n        case \"Group\":\n            return getGroupPrefix(element, direction, options, flags);\n        case \"Quantifier\":\n            return getQuantifierPrefix(element, direction, options, flags);\n        case \"Backreference\": {\n            if (isEmptyBackreference(element)) {\n                return EMPTY_COMPLETE;\n            }\n            if (isStrictBackreference(element)) {\n                const inner = getElementPrefix(element.resolved, direction, Object.assign(Object.assign({}, options), { includeAfter: false }), flags);\n                return inner;\n            }\n            if (!mayLookAhead(element, options, direction)) {\n                return EMPTY_INCOMPLETE;\n            }\n            const look = FirstConsumedChars.toLook(getFirstConsumedCharPlusAfter(element, direction, flags));\n            return { chars: [look.char], complete: false };\n        }\n        default:\n            assertNever(element);\n    }\n}\nfunction getGroupPrefix(element, direction, options, flags) {\n    const alternatives = element.alternatives.map(a => getAlternativePrefix(a, direction, options, flags));\n    if (alternatives.length === 1) {\n        return alternatives[0];\n    }\n    const chars = [];\n    let complete = true;\n    /** Counts the number of different characters in strict mode */\n    let differentCount = 0;\n    for (let i = 0; complete; i++) {\n        const cs = [];\n        let end = false;\n        for (const a of alternatives) {\n            if (i >= a.chars.length) {\n                end = true;\n            }\n            else {\n                cs.push(a.chars[i]);\n                if (i === a.chars.length - 1 && !a.complete && options.includeAfter) {\n                    complete = false;\n                }\n            }\n        }\n        if (cs.length === 0) {\n            // This means that all alternatives are complete and have the same\n            // length, so we can stop here.\n            break;\n        }\n        if (end) {\n            // This means that one (but not all) complete alternatives have\n            // reached the end, so we have consider the chars after the group.\n            complete = false;\n            if (!mayLookAheadAfter(element, options, direction)) {\n                break;\n            }\n            cs.push(getFirstCharAfter(element, direction, flags).char);\n        }\n        else if (!options.looseGroups) {\n            if (complete && cs.some(c => !c.equals(cs[0]))) {\n                differentCount++;\n            }\n            if (differentCount >= 2) {\n                complete = false;\n                if (!options.includeAfter) {\n                    break;\n                }\n            }\n        }\n        const total = cs[0].union(...cs.slice(1));\n        chars.push(total);\n    }\n    return { chars, complete };\n}\nfunction getQuantifierPrefix(element, direction, options, flags) {\n    if (isZeroLength(element)) {\n        return EMPTY_COMPLETE;\n    }\n    if (isLengthRangeMinZero(element)) {\n        if (!mayLookAhead(element, options, direction)) {\n            return EMPTY_INCOMPLETE;\n        }\n        const look = FirstConsumedChars.toLook(getFirstConsumedCharPlusAfter(element, direction, flags));\n        return { chars: [look.char], complete: false };\n    }\n    const inner = getElementPrefix(element.element, direction, options, flags);\n    if (!inner.complete) {\n        return inner;\n    }\n    if (inner.chars.length === 0) {\n        // The quantifier is not of length zero and the inner element is complete.\n        // If the algorithm is implemented correctly, `inner` will be at least on character long.\n        throw new Error(`Expected the quantifier '${element.raw}' to consume at least one character.`);\n    }\n    const chars = [];\n    for (let i = 0; i < element.min; i++) {\n        chars.push(...inner.chars);\n        if (chars.length > 1000) {\n            // this is a safe-guard to protect against regexes like a{1000000}\n            return { chars, complete: false };\n        }\n    }\n    if (element.min === element.max) {\n        return { chars, complete: true };\n    }\n    if (mayLookAheadAfter(element, options, direction)) {\n        const look = getFirstCharAfter(element, direction, flags);\n        chars.push(look.char.union(inner.chars[0]));\n    }\n    return { chars, complete: false };\n}\n/**\n * This operations is equal to:\n *\n * ```\n * concat(\n *     getFirstConsumedChar(element, direction, flags),\n *     getFirstConsumedCharAfter(element, direction, flags),\n * )\n * ```\n */\nfunction getFirstConsumedCharPlusAfter(element, direction, flags) {\n    const consumed = getFirstConsumedChar(element, direction, flags);\n    if (!consumed.empty) {\n        return consumed;\n    }\n    return FirstConsumedChars.concat([consumed, getFirstConsumedCharAfter(element, direction, flags)], flags);\n}\nfunction getFirstCharAfterAlternative(alternative, direction, flags) {\n    const { elements } = alternative;\n    const last = direction === \"rtl\" ? 0 : elements.length - 1;\n    const inc = direction === \"ltr\" ? +1 : -1;\n    // The idea here is to go back as far as possible into the alternative without consuming a characters.\n    // This allows assertions inside the alternative to affect the character after it.\n    let afterThis = last;\n    while (afterThis >= 0 && afterThis < elements.length && isZeroLength(elements[afterThis])) {\n        afterThis -= inc;\n    }\n    if (afterThis >= 0 && afterThis < elements.length) {\n        return getFirstCharAfter(elements[afterThis], direction, flags);\n    }\n    else {\n        return FirstConsumedChars.toLook(getFirstConsumedCharPlusAfter(alternative, direction, flags));\n    }\n}\nfunction mayLookAhead(element, options, direction) {\n    if (!options.includeAfter) {\n        return false;\n    }\n    if (options.onlyInside) {\n        return isNextCharacterInside(element, direction, options.root);\n    }\n    return true;\n}\nfunction mayLookAheadAfter(element, options, direction) {\n    if (!options.includeAfter) {\n        return false;\n    }\n    if (options.onlyInside) {\n        return isNextCharacterInsideAfter(element, direction, options.root);\n    }\n    return true;\n}\nfunction isNextCharacterInside(element, direction, root) {\n    return !isLengthRangeMinZero(element) || isNextCharacterInsideAfter(element, direction, root);\n}\n/**\n * Returns whether the next character consumed after `afterThis` is entirely determined by the elements of the given\n * `root` alternative.\n *\n * This assumes that `afterThis` is a descendant of `root`.\n */\nfunction isNextCharacterInsideAfter(afterThis, direction, root) {\n    const parent = afterThis.parent;\n    if (parent.type === \"CharacterClass\" || parent.type === \"CharacterClassRange\") {\n        throw new Error(\"Expected an element outside a character class.\");\n    }\n    if (parent.type === \"Quantifier\") {\n        return isNextCharacterInsideAfter(parent, direction, root);\n    }\n    const inc = direction === \"ltr\" ? +1 : -1;\n    const start = parent.elements.indexOf(afterThis);\n    for (let i = start + inc; i >= 0 && i < parent.elements.length; i += inc) {\n        const e = parent.elements[i];\n        if (!isLengthRangeMinZero(e)) {\n            return true;\n        }\n    }\n    if (parent === root) {\n        // since we reached the root, we couldn't find something is consumed a character\n        return false;\n    }\n    const grandparent = parent.parent;\n    if (grandparent.type === \"Pattern\") {\n        throw new Error(\"Expected the given element to be a descendant of the root alternative.\");\n    }\n    if (grandparent.type === \"Assertion\") {\n        // honestly, this doesn't make sense, so let's just throw an error\n        throw new Error();\n    }\n    return isNextCharacterInsideAfter(grandparent, direction, root);\n}\n","import { CharBase } from \"refa\";\nimport { getLongestPrefix } from \"./longest-prefix\";\nimport { assertSameParent, SetEquivalence } from \"./util\";\n/**\n * This splits the set of alternative into disjoint non-empty equivalence\n * classes based on the characters consumed by the alternatives. The\n * equivalence classes can be reordered freely but elements within an\n * equivalence class have to be proven to be reorderable.\n *\n * The idea of determinism is that we can reorder alternatives freely if the\n * regex engine doesn't have a choice as to which alternative to take.\n *\n * E.g. we can freely reorder the alternatives `food|butter|bread` because the\n * alternatives are not a prefix of each other and do not overlap. On the other\n * hand, the alternatives `a|aa` cannot be reordered without affecting the\n * regex.\n *\n * @param alternatives A set of alternatives with the same parent.where all\n * alternatives have the same parent.\n *\n * The collection must be possible to iterate multiple times. Ideally, the\n * backing data structure of this parameter is `Set` but other collection types\n * are also possible.\n * @param dir The direction from which characters are read to determine the\n * equivalence classes.\n *\n * Alternatives can have different equivalence classes depending on the\n * direction from which characters are read. E.g. when reading `a|ba` left to\n * right, the alternatives can be reordered, but not when reading from right to\n * left.\n *\n * The `\"unknown\"` option ensures that the returned equivalence classes hold\n * true regardless of direction. This option can also be thought of as \"both\"\n * directions.\n *\n * Example: Here are the results of this function for `ab|ac|bc` with all\n * direction options:\n *\n * - `\"left\"`: ``[[`ab`, `ac`], [`bc`]]``\n * - `\"right\"`: ``[[`ab`], [`ac`, `bc`]]``\n * - `\"unknown\"`: ``[[`ab`, `ac`, `bc`]]``\n * @param flags The flags of the regex of the given alternatives.\n */\nexport function getDeterminismEqClasses(alternatives, dir, flags) {\n    assertSameParent(alternatives);\n    if (dir === \"unknown\") {\n        return getDirectionIndependentDeterminismEqClasses(alternatives, flags);\n    }\n    return getDirectionalDeterminismEqClasses(alternatives, dir, flags);\n}\n/**\n * This will return equivalence classes independent of the matching direction\n * of the given alternatives.\n */\nfunction getDirectionIndependentDeterminismEqClasses(alternatives, flags) {\n    const ltr = getDirectionalDeterminismEqClasses(alternatives, \"ltr\", flags);\n    const rtl = getDirectionalDeterminismEqClasses(alternatives, \"rtl\", flags);\n    const disjoint = mergeOverlappingSets([...ltr, ...rtl], s => s);\n    const result = [];\n    for (const sets of disjoint) {\n        const eq = new Set();\n        for (const s of sets) {\n            s.forEach(a => eq.add(a));\n        }\n        result.push([...eq]);\n    }\n    return result;\n}\nconst LONGEST_PREFIX_OPTIONS = {\n    includeAfter: true,\n    looseGroups: true,\n};\n/**\n * This splits the set of alternative into disjoint non-empty equivalence\n * classes based on the characters consumed. The equivalence classes can be\n * reordered freely but elements within an equivalence class have to be proven\n * to be reorderable.\n *\n * The idea of determinism is that we can reorder alternatives freely if the\n * regex engine doesn't have a choice as to which alternative to take.\n *\n * E.g. we can freely reorder the alternatives `food|butter|bread` because the\n * alternative are not a prefix of each other and do not overlap.\n */\nfunction getDirectionalDeterminismEqClasses(alternatives, dir, flags) {\n    // Step 1:\n    // We map each alternative to an array of CharSets. Each array represents a\n    // concatenation that we are sure of. E.g. the alternative `abc*de` will\n    // get the array `a, b, [cd]`, and `abc` will get `a, b, c`.\n    const getPrefixCharSets = cachedFn(a => {\n        let prefix = getLongestPrefix(a, dir, flags, LONGEST_PREFIX_OPTIONS);\n        // We optimize a little here.\n        // All trailing all-characters sets can be removed without affecting\n        // the result of the equivalence classes.\n        let all = 0;\n        for (let i = prefix.length - 1; i >= 0; i--) {\n            if (prefix[i].isAll) {\n                all++;\n            }\n            else {\n                break;\n            }\n        }\n        if (all > 0) {\n            prefix = prefix.slice(0, prefix.length - all);\n        }\n        return prefix;\n    });\n    // Step 2:\n    // Remap the prefix CharSets to use base sets instead. The following\n    // operations will scale linearly with the number of characters. By using\n    // base sets instead of the raw CharSets, we can drastically reduce the\n    // number \"logical\" characters. It's the same trick refa uses for its DFA\n    // operations (creation, minimization).\n    const allCharSets = new Set();\n    for (const a of alternatives) {\n        getPrefixCharSets(a).forEach(cs => allCharSets.add(cs));\n    }\n    const base = new CharBase(allCharSets);\n    const prefixes = [];\n    for (const a of alternatives) {\n        prefixes.push({\n            characters: getPrefixCharSets(a).map(cs => base.split(cs)),\n            alternative: a,\n        });\n    }\n    // Step 3:\n    // Create equivalence classes from the prefixes. In the first iteration, we\n    // will only look at the first character and create equivalence classes\n    // based on that. Then we will try to further sub-divide the equivalence\n    // classes based on the second character of the prefixes. This sub-division\n    // process will continue until one prefix in the a equivalence class runs\n    // out of characters.\n    /** Subdivide */\n    function subdivide(eqClass, index) {\n        if (eqClass.length < 2) {\n            return [eqClass];\n        }\n        for (const prefix of eqClass) {\n            if (index >= prefix.characters.length) {\n                // ran out of characters\n                return [eqClass];\n            }\n        }\n        const disjointSets = mergeOverlappingSets(eqClass, p => p.characters[index]);\n        const result = [];\n        for (const set of disjointSets) {\n            result.push(...subdivide(set, index + 1));\n        }\n        return result;\n    }\n    return subdivide(prefixes, 0).map(eq => eq.map(p => p.alternative));\n}\n/**\n * Given a set of sets (`S`), this will merge all overlapping sets until all\n * sets are disjoint.\n *\n * This assumes that all sets contain at least one element.\n *\n * This function will not merge the given sets itself. Instead, it will\n * return an iterable of sets (`Set<S>`) of sets (`S`) to merge. Each set (`S`)\n * is guaranteed to be returned exactly once.\n *\n * Note: Instead of actual JS `Set` instances, the implementation will treat\n * `readonly S[]` instances as sets. This makes the whole implementation a lot\n * more efficient.\n */\nfunction mergeOverlappingSets(sets, getElements) {\n    if (sets.length < 2) {\n        return [sets];\n    }\n    const eq = new SetEquivalence(sets.length);\n    const elementMap = new Map();\n    for (let i = 0; i < sets.length; i++) {\n        const s = sets[i];\n        for (const e of getElements(s)) {\n            const elementSet = elementMap.get(e);\n            if (elementSet === undefined) {\n                // It's the first time we see this element.\n                elementMap.set(e, i);\n            }\n            else {\n                // We've seen this element before in another set.\n                // Make the 2 sets equal.\n                eq.makeEqual(i, elementSet);\n            }\n        }\n    }\n    const eqSets = eq.getEquivalenceSets();\n    const result = [];\n    for (let i = 0; i < eqSets.count; i++) {\n        result.push([]);\n    }\n    for (let i = 0; i < sets.length; i++) {\n        result[eqSets.indexes[i]].push(sets[i]);\n    }\n    return result;\n}\n/**\n * Create a new cached function.\n */\nfunction cachedFn(fn) {\n    /** */\n    function wrapper(value) {\n        let cached = wrapper.cache.get(value);\n        if (cached === undefined) {\n            cached = fn(value);\n            wrapper.cache.set(value, cached);\n        }\n        return cached;\n    }\n    wrapper.cache = new Map();\n    return wrapper;\n}\n","import { containsCapturingGroup, getLengthRange, getMatchingDirection, hasSomeDescendant, isEmptyBackreference, } from \"./basic\";\nimport { toCache } from \"./cache\";\nimport { Chars } from \"./chars\";\nimport { getDeterminismEqClasses } from \"./determinism\";\nimport { getFirstCharAfter } from \"./next-char\";\nimport { toCharSet } from \"./to-char-set\";\nimport { asReadonlySet, assertSameParent } from \"./util\";\n/**\n * Returns whether the given alternatives can all be reordered.\n *\n * In other words, given a set of alternatives, this will return whether all\n * permutations of those alternatives behave exactly the same as the current\n * permutation of those alternatives.\n *\n * The function makes one more guarantee when some alternatives of the same\n * parent are not given. Let `T` be the set of the given alternatives and let\n * `U` be the set of alternatives that are **not** given and have the same\n * parent as the given alternatives. Let `M` be all alternatives in `U` that\n * are positioned between two alternatives `T`. As long as the relative order\n * of the alternatives in `M` is preserved, all permutations of `T âˆª M` are\n * guaranteed to be have equivalently.\n *\n * Note that this function makes no guarantees about the alternative\n * `U \\ (T âˆª M)`. Permutations that change the position of those alternatives\n * are **not** guaranteed to be valid.\n *\n * Example: `/0|1|2|ðŸ’š|3|4|ðŸ’¯|ðŸ‘‹|5|6/` with `T = ðŸ’š|ðŸ’¯|ðŸ‘‹`, `U = 0|1|2|3|4|5|6`, and\n * `M = 3|4`.\n *\n * This function will return `true` and the following are **guaranteed** to be\n * valid permutations:\n *\n * - `/0|1|2|ðŸ’š|3|4|ðŸ’¯|ðŸ‘‹|5|6/` (unchanged)\n * - `/0|1|2|3|ðŸ’š|4|ðŸ’¯|ðŸ‘‹|5|6/`\n * - `/0|1|2|3|4|ðŸ’š|ðŸ’¯|ðŸ‘‹|5|6/`\n * - `/0|1|2|ðŸ’š|ðŸ’¯|3|4|ðŸ‘‹|5|6/`\n * - `/0|1|2|ðŸ’š|ðŸ’¯|ðŸ‘‹|3|4|5|6/`\n * - `/0|1|2|ðŸ‘‹|ðŸ’¯|ðŸ’š|3|4|5|6/`\n * - `/0|1|2|ðŸ‘‹|3|4|ðŸ’¯|ðŸ’š|5|6/`\n *\n * The following are **not guaranteed** to be valid permutations:\n *\n * - `/0|1|2|ðŸ’š|4|3|ðŸ’¯|ðŸ‘‹|5|6/` (`3` and `4` were swapped)\n * - `/ðŸ’š|0|1|2|3|4|ðŸ’¯|ðŸ‘‹|5|6/` (the position of `0` was changed)\n * - `/0|1|2|ðŸ’š|3|4|ðŸ‘‹|5|6|ðŸ’¯/` (the position of `6` was changed)\n */\nexport function canReorder(alternatives, flags, options = {}) {\n    flags = toCache(flags);\n    const { ignoreCapturingGroups = false, matchingDirection } = options;\n    const target = asReadonlySet(alternatives);\n    if (target.size < 2) {\n        // we can trivially reorder 0 or 1 alternatives\n        return true;\n    }\n    assertSameParent(target);\n    const slice = getAlternativesSlice(target);\n    const direction = matchingDirection !== null && matchingDirection !== void 0 ? matchingDirection : getMatchingDirection(slice[0]);\n    if (direction === \"unknown\") {\n        return (canReorderDirectional(target, slice, \"ltr\", flags, ignoreCapturingGroups) &&\n            canReorderDirectional(target, slice, \"rtl\", flags, ignoreCapturingGroups));\n    }\n    return canReorderDirectional(target, slice, direction, flags, ignoreCapturingGroups);\n}\nexport function canReorderDirectional(target, slice, direction, flags, ignoreCapturingGroups) {\n    const eqClasses = getDeterminismEqClasses(slice, direction, flags);\n    if (!ignoreCapturingGroups && !canReorderCapturingGroups(target, slice, eqClasses)) {\n        return false;\n    }\n    // from this point onward, we don't have to worry about capturing groups\n    // anymore\n    // we only have to prove that we can reorder alternatives within each\n    // equivalence class.\n    return eqClasses.every(eq => {\n        if (eq.length < 2) {\n            return true;\n        }\n        if (eq.every(a => !target.has(a))) {\n            // This equivalence class contains only non-target alternatives.\n            // As by the guarantees provided by this function, these\n            // alternatives are not required to be reorderable.\n            return true;\n        }\n        return canReorderBasedOnLength(eq) || canReorderBasedOnConsumedChars(eq, direction, flags);\n    });\n}\n/**\n * Returns whether the capturing groups in the slice alternative can be\n * reordered.\n */\nfunction canReorderCapturingGroups(target, slice, eqClasses) {\n    // Reordering and capturing groups:\n    // Reordering doesn't play well with capturing groups because changing\n    // the order of two capturing groups is a change that can be observed\n    // by the user and might break the regex. So we have to avoid changing\n    // the relative order of two alternatives with capturing groups.\n    //\n    // Since target alternatives can be reordered, there must be at most one\n    // target alternative containing capturing groups. If one target\n    // alternative contains capturing groups, no other alternative in the\n    // slice is allowed to contain capturing groups.\n    let targetCG = 0;\n    let nonTargetCG = 0;\n    for (const a of slice) {\n        if (containsCapturingGroup(a)) {\n            if (target.has(a)) {\n                targetCG++;\n            }\n            else {\n                nonTargetCG++;\n            }\n        }\n    }\n    if (targetCG > 1 || (targetCG === 1 && nonTargetCG !== 0)) {\n        return false;\n    }\n    if (nonTargetCG !== 0) {\n        // A equivalence class containing a capturing group must not contain a\n        // target alternative.\n        //\n        // Here is an example where this doesn't work: `/^(?:a|(b)|b)$/` with\n        // the targets `a` and `b`. Since `/^(?:a|(b)|b)$/` !=\n        // `/^(?:a|b|(b))$/`, we cannot reorder the target alternatives.\n        return eqClasses.every(eq => {\n            return (\n            // no capturing groups\n            !eq.some(containsCapturingGroup) ||\n                // or no target alternatives\n                eq.every(a => !target.has(a)));\n        });\n    }\n    else if (targetCG !== 0) {\n        // The target alternative with the capturing group must be in its own\n        // equivalence class.\n        return eqClasses.every(eq => {\n            return eq.length < 2 || !eq.some(containsCapturingGroup);\n        });\n    }\n    return true;\n}\n/**\n * Returns whether alternatives can be reordered because they all have the same\n * length.\n *\n * No matter which alternative the regex engine picks, we will always end up in\n * the same place after.\n */\nfunction canReorderBasedOnLength(slice) {\n    const lengthRange = getLengthRange(slice);\n    return Boolean(lengthRange && lengthRange.min === lengthRange.max);\n}\n/**\n * Returns whether alternatives can be reordered because the characters\n * consumed.\n *\n * If the given alternatives are followed (in their current matching direction)\n * by characters not consumed by the alternatives, then the order order of the\n * alternatives doesn't matter.\n *\n * Furthermore, we can factor out common prefixes and suffixes. E.g. checking\n * whether `(?:foobar|footwear)` can be reordered is the same as checking\n * whether `foo(?:b|twe)ar` can be reordered. Using this idea, we can narrow\n * down the consumed characters and find additional characters that also have\n * to be disjoint with the consumed characters.\n */\nfunction canReorderBasedOnConsumedChars(slice, direction, flags) {\n    const factoredOut = factorOutCommon(slice.map(a => a.elements), flags);\n    const elements = [];\n    for (const alternative of factoredOut.rest) {\n        elements.push(...alternative);\n    }\n    const consumedChars = Chars.empty(flags).union(...elements.map(e => getConsumedChars(e, flags)));\n    // we first check all suffix characters because we get them for free when factoring out.\n    const suffix = direction === \"ltr\" ? factoredOut.right : factoredOut.left;\n    if (suffix.some(cs => cs.isDisjointWith(consumedChars))) {\n        return true;\n    }\n    // now we check the character after the parent of the given alternatives\n    const parent = slice[0].parent;\n    if (parent.type === \"Pattern\" || parent.type === \"Assertion\") {\n        return false;\n    }\n    return getFirstCharAfter(parent, direction, flags).char.isDisjointWith(consumedChars);\n}\nfunction factorOutCommon(alternatives, flags) {\n    const prefix = factorOutCommonPrefix(alternatives, \"ltr\", flags);\n    const suffix = factorOutCommonPrefix(prefix.rest, \"rtl\", flags);\n    return { left: prefix.prefix, right: suffix.prefix, rest: suffix.rest };\n}\nfunction factorOutCommonPrefix(alternatives, direction, flags) {\n    const prefix = getLongestPureCharPrefix(alternatives, direction, flags);\n    if (prefix.length === 0) {\n        return { prefix, rest: alternatives };\n    }\n    else {\n        // remove prefix\n        return {\n            prefix,\n            rest: alternatives.map(elements => {\n                const start = direction === \"ltr\" ? prefix.length : 0;\n                const end = direction === \"ltr\" ? elements.length : elements.length - prefix.length;\n                return elements.slice(start, end);\n            }),\n        };\n    }\n}\nfunction getLongestPureCharPrefix(alternatives, direction, flags) {\n    const prefix = [];\n    for (let i = 0;; i++) {\n        let char = null;\n        for (const elements of alternatives) {\n            const current = direction === \"ltr\" ? i : elements.length - 1 - i;\n            if (i >= 0 && i < elements.length) {\n                const element = elements[current];\n                switch (element.type) {\n                    case \"Character\":\n                    case \"CharacterClass\":\n                    case \"CharacterSet\":\n                        if (char === null) {\n                            char = toCharSet(element, flags);\n                        }\n                        else {\n                            if (!char.equals(toCharSet(element, flags))) {\n                                return prefix;\n                            }\n                        }\n                        break;\n                    default:\n                        return prefix;\n                }\n            }\n            else {\n                return prefix;\n            }\n        }\n        if (char === null)\n            throw new Error();\n        prefix.push(char);\n    }\n}\n/**\n * Returns the smallest slice of alternatives that contains all given\n * alternatives.\n */\nfunction getAlternativesSlice(set) {\n    if (set.size <= 1) {\n        return [...set];\n    }\n    let first;\n    for (const item of set) {\n        first = item;\n        break;\n    }\n    if (!first) {\n        throw new Error();\n    }\n    const parentAlternatives = first.parent.alternatives;\n    let min = set.size;\n    let max = 0;\n    for (let i = 0; i < parentAlternatives.length; i++) {\n        const a = parentAlternatives[i];\n        if (set.has(a)) {\n            min = Math.min(min, i);\n            max = Math.max(max, i);\n        }\n    }\n    return parentAlternatives.slice(min, max + 1);\n}\n/**\n * Returns the union of all characters that can possibly be consumed by the\n * given element.\n */\nfunction getConsumedChars(element, flags) {\n    const sets = [];\n    // we misuse hasSomeDescendant to iterate all relevant elements\n    hasSomeDescendant(element, d => {\n        if (d.type === \"Character\" || d.type === \"CharacterClass\" || d.type === \"CharacterSet\") {\n            sets.push(toCharSet(d, flags));\n        }\n        else if (d.type === \"Backreference\" && !isEmptyBackreference(d)) {\n            sets.push(getConsumedChars(d.resolved, flags));\n        }\n        // always continue to the next element\n        return false;\n    }, \n    // don't go into assertions\n    d => d.type !== \"Assertion\" && d.type !== \"CharacterClass\");\n    return Chars.empty(flags).union(...sets);\n}\n"],"names":["assertNever","value","message","Error","assertSameParent","alternatives","parent","a","Chars","EMPTY_UTF16_CHARSET","CharSet","empty","EMPTY_UNICODE_CHARSET","flags","unicode","ALL_UTF16_CHARSET","all","ALL_UNICODE_CHARSET","LINE_TERMINATOR_UTF16_CHARSET","JS","createCharSet","kind","negate","LINE_TERMINATOR_UNICODE_CHARSET","lineTerminator","WORD_UTF16_CHARSET","WORD_UNICODE_CHARSET","ignoreCase","WORD_UNICODE_IGNORE_CASE_CHARSET","word","DIGIT_UTF16_CHARSET","DIGIT_UNICODE_CHARSET","digit","SPACE_UTF16_CHARSET","SPACE_UNICODE_CHARSET","space","isReadonlyArray","Array","isArray","CharUnion","constructor","this","_exactChars","_inexactChars","char","union","exact","isSupersetOf","add","static","maximum","intersectInexact","left","right","intersect","isEmpty","SetEquivalence","count","_indexes","i","push","makeEqual","b","aValue","bValue","getEquivalenceSets","counter","indexes","isInvokeEvery","element","fn","every","isInvokeSome","some","isZeroLength","isZeroLengthImpl","type","elements","max","isEmptyBackreference","length","isPotentiallyZeroLengthImpl","e","root","impl","backreferenceIsPotentiallyEmpty","min","isEmptyImpl","isPotentiallyEmptyImpl","back","hasSomeAncestor","resolved","isStrictBackreference","node","condition","hasSomeAncestorFnImpl","hasSomeAncestorNodeImpl","hasSomeDescendant","descentConditionFn","hasSomeDescendantImpl","d","conditionFn","pattern","getPattern","p","getMatchingDirection","closestLookaround","undefined","invertMatchingDirection","direction","getMatchingDirectionFromAssertionKind","backreference","group","closestAncestor","getClosestAncestor","backRefAncestors","Set","findBackreference","index","indexOf","next","slice","has","parentParent","containsCapturingGroup","isCapturingGroup","ZERO_LENGTH_RANGE","ONE_LENGTH_RANGE","getLengthRange","getLengthRangeAlternativesImpl","getLengthRangeElementImpl","Infinity","eRange","Math","RangeError","elementRange","resolvedRange","isLengthRangeMinZero","isLengthRangeMinZeroAlternativesImpl","isLengthRangeMinZeroElementImpl","args","reduce","getClosestAncestorImpl","aPath","getPathToRoot","bPath","pop","path","an","toCache","CacheInstance","from","toCharSet","WeakMap","getFirstConsumedCharLTR","getFirstConsumedCharRTL","getLongestPrefix","Map","dotAll","global","hasIndices","multiline","sticky","toCharSetSimpleCached","positive","negated","categorizeElements","makeRefaCompatible","map","c","cached","get","toCharSetSimple","set","cs","toRefaCharElement","structurallyEqual","x","y","other","manyAreStructurallyEqual","otherLookaround","raw","key","greedy","followPaths","start","startMode","initialState","operations","opEnter","state","_a","_b","enter","continueInto","call","assertionDirection","assertion","join","enterAlternative","doFork","endPath","assert","leave","alternative","increment","continueAfter","getNextElement","nextIndex","nextElement","continueOutside","reason","after","quant","opNext","fork","FirstLookChars","FirstConsumedChars","edge","toConsumed","look","emptyConcat","emptyUnion","toLook","consumed","unionInexact","chars","fromFlags","looks","itemChar","lookUnion","concat","item","lookIntersection","makeOptional","ImplOptions","_currentWordBoundaries","_ltrCache","_rtlCache","isCurrentWordBoundary","pushWordBoundary","popWordBoundary","getCached","dir","setCached","result","getFirstConsumedChar","options","getFirstConsumedCharAlternativesImpl","getFirstConsumedCharImpl","misdirectedAssertion","before","getFirstCharAfterImpl","isDisjointWith","wordAssertion","isSubsetOf","lineAssertion","edgeAssertion","firstChar","range","getFirstConsumedCharAssertionImpl","reverse","resolvedChar","size","Object","assign","getFirstConsumedCharUncachedImpl","getFirstConsumedCharAfter","afterThis","getFirstConsumedCharAfterImpl","states","first","_","getFirstCharAfter","getFirstConsumedCharAfterWithContributorsImpl","option","contributors","forEach","s","cacheInstance","includeAfter","onlyInside","looseGroups","cache","cacheKey","weakCache","complete","getAlternativePrefix","last","inc","getFirstConsumedCharPlusAfter","getFirstCharAfterAlternative","getLongestPrefixImpl","EMPTY_COMPLETE","EMPTY_INCOMPLETE","inner","getElementPrefix","differentCount","end","mayLookAheadAfter","equals","total","getGroupPrefix","mayLookAhead","getQuantifierPrefix","isNextCharacterInsideAfter","isNextCharacterInside","grandparent","getDeterminismEqClasses","ltr","getDirectionalDeterminismEqClasses","rtl","disjoint","mergeOverlappingSets","sets","eq","getDirectionIndependentDeterminismEqClasses","LONGEST_PREFIX_OPTIONS","getPrefixCharSets","wrapper","cachedFn","prefix","isAll","allCharSets","base","CharBase","prefixes","characters","split","subdivide","eqClass","disjointSets","getElements","elementMap","elementSet","eqSets","canReorderDirectional","target","ignoreCapturingGroups","eqClasses","targetCG","nonTargetCG","canReorderCapturingGroups","lengthRange","Boolean","canReorderBasedOnLength","factoredOut","factorOutCommonPrefix","suffix","rest","factorOutCommon","consumedChars","getConsumedChars","canReorderBasedOnConsumedChars","current","getLongestPureCharPrefix","matchingDirection","iter","parentAlternatives","getAlternativesSlice","found","visitRegExpAST","onCapturingGroupEnter","error","n","getFirstCharAfterWithContributorsImpl"],"mappings":"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"}